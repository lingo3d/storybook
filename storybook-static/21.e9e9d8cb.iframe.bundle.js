(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{"./node_modules/lingo3d/lib/display/utils/loaders/loadSVG.js":function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);var three_module=__webpack_require__("./node_modules/three/build/three.module.js");class SVGLoader_SVGLoader extends three_module.Ab{constructor(manager){super(manager),this.defaultDPI=90,this.defaultUnit="px"}load(url,onLoad,onProgress,onError){const scope=this,loader=new three_module.U(scope.manager);loader.setPath(scope.path),loader.setRequestHeader(scope.requestHeader),loader.setWithCredentials(scope.withCredentials),loader.load(url,(function(text){try{onLoad(scope.parse(text))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}}),onProgress,onError)}parse(text){const scope=this;function parseArcCommand(path,rx,ry,x_axis_rotation,large_arc_flag,sweep_flag,start,end){if(0==rx||0==ry)return void path.lineTo(end.x,end.y);x_axis_rotation=x_axis_rotation*Math.PI/180,rx=Math.abs(rx),ry=Math.abs(ry);const dx2=(start.x-end.x)/2,dy2=(start.y-end.y)/2,x1p=Math.cos(x_axis_rotation)*dx2+Math.sin(x_axis_rotation)*dy2,y1p=-Math.sin(x_axis_rotation)*dx2+Math.cos(x_axis_rotation)*dy2;let rxs=rx*rx,rys=ry*ry;const x1ps=x1p*x1p,y1ps=y1p*y1p,cr=x1ps/rxs+y1ps/rys;if(cr>1){const s=Math.sqrt(cr);rxs=(rx*=s)*rx,rys=(ry*=s)*ry}const dq=rxs*y1ps+rys*x1ps,pq=(rxs*rys-dq)/dq;let q=Math.sqrt(Math.max(0,pq));large_arc_flag===sweep_flag&&(q=-q);const cxp=q*rx*y1p/ry,cyp=-q*ry*x1p/rx,cx=Math.cos(x_axis_rotation)*cxp-Math.sin(x_axis_rotation)*cyp+(start.x+end.x)/2,cy=Math.sin(x_axis_rotation)*cxp+Math.cos(x_axis_rotation)*cyp+(start.y+end.y)/2,theta=svgAngle(1,0,(x1p-cxp)/rx,(y1p-cyp)/ry),delta=svgAngle((x1p-cxp)/rx,(y1p-cyp)/ry,(-x1p-cxp)/rx,(-y1p-cyp)/ry)%(2*Math.PI);path.currentPath.absellipse(cx,cy,rx,ry,theta,theta+delta,0===sweep_flag,x_axis_rotation)}function svgAngle(ux,uy,vx,vy){const dot=ux*vx+uy*vy,len=Math.sqrt(ux*ux+uy*uy)*Math.sqrt(vx*vx+vy*vy);let ang=Math.acos(Math.max(-1,Math.min(1,dot/len)));return ux*vy-uy*vx<0&&(ang=-ang),ang}function parseStyle(node,style){style=Object.assign({},style);let stylesheetStyles={};if(node.hasAttribute("class")){const classSelectors=node.getAttribute("class").split(/\s/).filter(Boolean).map((i=>i.trim()));for(let i=0;i<classSelectors.length;i++)stylesheetStyles=Object.assign(stylesheetStyles,stylesheets["."+classSelectors[i]])}function addStyle(svgName,jsName,adjustFunction){void 0===adjustFunction&&(adjustFunction=function copy(v){return v.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),v}),node.hasAttribute(svgName)&&(style[jsName]=adjustFunction(node.getAttribute(svgName))),stylesheetStyles[svgName]&&(style[jsName]=adjustFunction(stylesheetStyles[svgName])),node.style&&""!==node.style[svgName]&&(style[jsName]=adjustFunction(node.style[svgName]))}function clamp(v){return Math.max(0,Math.min(1,parseFloatWithUnits(v)))}function positive(v){return Math.max(0,parseFloatWithUnits(v))}return node.hasAttribute("id")&&(stylesheetStyles=Object.assign(stylesheetStyles,stylesheets["#"+node.getAttribute("id")])),addStyle("fill","fill"),addStyle("fill-opacity","fillOpacity",clamp),addStyle("fill-rule","fillRule"),addStyle("opacity","opacity",clamp),addStyle("stroke","stroke"),addStyle("stroke-opacity","strokeOpacity",clamp),addStyle("stroke-width","strokeWidth",positive),addStyle("stroke-linejoin","strokeLineJoin"),addStyle("stroke-linecap","strokeLineCap"),addStyle("stroke-miterlimit","strokeMiterLimit",positive),addStyle("visibility","visibility"),style}function getReflection(a,b){return a-(b-a)}function parseFloats(input,flags,stride){if("string"!=typeof input)throw new TypeError("Invalid input: "+typeof input);const RE={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/};let state=0,seenComma=!0,number="",exponent="";const result=[];function throwSyntaxError(current,i,partial){const error=new SyntaxError('Unexpected character "'+current+'" at index '+i+".");throw error.partial=partial,error}function newNumber(){""!==number&&(""===exponent?result.push(Number(number)):result.push(Number(number)*Math.pow(10,Number(exponent)))),number="",exponent=""}let current;const length=input.length;for(let i=0;i<length;i++)if(current=input[i],Array.isArray(flags)&&flags.includes(result.length%stride)&&RE.FLAGS.test(current))state=1,number=current,newNumber();else{if(0===state){if(RE.WHITESPACE.test(current))continue;if(RE.DIGIT.test(current)||RE.SIGN.test(current)){state=1,number=current;continue}if(RE.POINT.test(current)){state=2,number=current;continue}RE.COMMA.test(current)&&(seenComma&&throwSyntaxError(current,i,result),seenComma=!0)}if(1===state){if(RE.DIGIT.test(current)){number+=current;continue}if(RE.POINT.test(current)){number+=current,state=2;continue}if(RE.EXP.test(current)){state=3;continue}RE.SIGN.test(current)&&1===number.length&&RE.SIGN.test(number[0])&&throwSyntaxError(current,i,result)}if(2===state){if(RE.DIGIT.test(current)){number+=current;continue}if(RE.EXP.test(current)){state=3;continue}RE.POINT.test(current)&&"."===number[number.length-1]&&throwSyntaxError(current,i,result)}if(3===state){if(RE.DIGIT.test(current)){exponent+=current;continue}if(RE.SIGN.test(current)){if(""===exponent){exponent+=current;continue}1===exponent.length&&RE.SIGN.test(exponent)&&throwSyntaxError(current,i,result)}}RE.WHITESPACE.test(current)?(newNumber(),state=0,seenComma=!1):RE.COMMA.test(current)?(newNumber(),state=0,seenComma=!0):RE.SIGN.test(current)?(newNumber(),state=1,number=current):RE.POINT.test(current)?(newNumber(),state=2,number=current):throwSyntaxError(current,i,result)}return newNumber(),result}const units=["mm","cm","in","pt","pc","px"],unitConversion={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function parseFloatWithUnits(string){let scale,theUnit="px";if("string"==typeof string||string instanceof String)for(let i=0,n=units.length;i<n;i++){const u=units[i];if(string.endsWith(u)){theUnit=u,string=string.substring(0,string.length-u.length);break}}return"px"===theUnit&&"px"!==scope.defaultUnit?scale=unitConversion.in[scope.defaultUnit]/scope.defaultDPI:(scale=unitConversion[theUnit][scope.defaultUnit],scale<0&&(scale=unitConversion[theUnit].in*scope.defaultDPI)),scale*parseFloat(string)}function getTransformScaleX(m){const te=m.elements;return Math.sqrt(te[0]*te[0]+te[1]*te[1])}function getTransformScaleY(m){const te=m.elements;return Math.sqrt(te[3]*te[3]+te[4]*te[4])}const paths=[],stylesheets={},transformStack=[],tempTransform0=new three_module.Jb,tempTransform1=new three_module.Jb,tempTransform2=new three_module.Jb,tempTransform3=new three_module.Jb,tempV2=new three_module.td,tempV3=new three_module.ud,currentTransform=new three_module.Jb,xml=(new DOMParser).parseFromString(text,"image/svg+xml");!function parseNode(node,style){if(1!==node.nodeType)return;const transform=function getNodeTransform(node){if(!(node.hasAttribute("transform")||"use"===node.nodeName&&(node.hasAttribute("x")||node.hasAttribute("y"))))return null;const transform=function parseNodeTransform(node){const transform=new three_module.Jb,currentTransform=tempTransform0;if("use"===node.nodeName&&(node.hasAttribute("x")||node.hasAttribute("y"))){const tx=parseFloatWithUnits(node.getAttribute("x")),ty=parseFloatWithUnits(node.getAttribute("y"));transform.translate(tx,ty)}if(node.hasAttribute("transform")){const transformsTexts=node.getAttribute("transform").split(")");for(let tIndex=transformsTexts.length-1;tIndex>=0;tIndex--){const transformText=transformsTexts[tIndex].trim();if(""===transformText)continue;const openParPos=transformText.indexOf("("),closeParPos=transformText.length;if(openParPos>0&&openParPos<closeParPos){const transformType=transformText.slice(0,openParPos),array=parseFloats(transformText.slice(openParPos+1));switch(currentTransform.identity(),transformType){case"translate":if(array.length>=1){const tx=array[0];let ty=tx;array.length>=2&&(ty=array[1]),currentTransform.translate(tx,ty)}break;case"rotate":if(array.length>=1){let angle=0,cx=0,cy=0;angle=-array[0]*Math.PI/180,array.length>=3&&(cx=array[1],cy=array[2]),tempTransform1.identity().translate(-cx,-cy),tempTransform2.identity().rotate(angle),tempTransform3.multiplyMatrices(tempTransform2,tempTransform1),tempTransform1.identity().translate(cx,cy),currentTransform.multiplyMatrices(tempTransform1,tempTransform3)}break;case"scale":if(array.length>=1){const scaleX=array[0];let scaleY=scaleX;array.length>=2&&(scaleY=array[1]),currentTransform.scale(scaleX,scaleY)}break;case"skewX":1===array.length&&currentTransform.set(1,Math.tan(array[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":1===array.length&&currentTransform.set(1,0,0,Math.tan(array[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":6===array.length&&currentTransform.set(array[0],array[2],array[4],array[1],array[3],array[5],0,0,1)}}transform.premultiply(currentTransform)}}return transform}(node);transformStack.length>0&&transform.premultiply(transformStack[transformStack.length-1]);return currentTransform.copy(transform),transformStack.push(transform),transform}(node);let isDefsNode=!1,path=null;switch(node.nodeName){case"svg":break;case"style":!function parseCSSStylesheet(node){if(!node.sheet||!node.sheet.cssRules||!node.sheet.cssRules.length)return;for(let i=0;i<node.sheet.cssRules.length;i++){const stylesheet=node.sheet.cssRules[i];if(1!==stylesheet.type)continue;const selectorList=stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i=>i.trim()));for(let j=0;j<selectorList.length;j++){const definitions=Object.fromEntries(Object.entries(stylesheet.style).filter((([,v])=>""!==v)));stylesheets[selectorList[j]]=Object.assign(stylesheets[selectorList[j]]||{},definitions)}}}(node);break;case"g":style=parseStyle(node,style);break;case"path":style=parseStyle(node,style),node.hasAttribute("d")&&(path=function parsePathNode(node){const path=new three_module.Lc,point=new three_module.td,control=new three_module.td,firstPoint=new three_module.td;let isFirstPoint=!0,doSetFirstPoint=!1;const commands=node.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);for(let i=0,l=commands.length;i<l;i++){const command=commands[i],type=command.charAt(0),data=command.slice(1).trim();let numbers;switch(!0===isFirstPoint&&(doSetFirstPoint=!0,isFirstPoint=!1),type){case"M":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2)point.x=numbers[j+0],point.y=numbers[j+1],control.x=point.x,control.y=point.y,0===j?path.moveTo(point.x,point.y):path.lineTo(point.x,point.y),0===j&&firstPoint.copy(point);break;case"H":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j++)point.x=numbers[j],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"V":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j++)point.y=numbers[j],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"L":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2)point.x=numbers[j+0],point.y=numbers[j+1],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"C":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=6)path.bezierCurveTo(numbers[j+0],numbers[j+1],numbers[j+2],numbers[j+3],numbers[j+4],numbers[j+5]),control.x=numbers[j+2],control.y=numbers[j+3],point.x=numbers[j+4],point.y=numbers[j+5],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"S":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=4)path.bezierCurveTo(getReflection(point.x,control.x),getReflection(point.y,control.y),numbers[j+0],numbers[j+1],numbers[j+2],numbers[j+3]),control.x=numbers[j+0],control.y=numbers[j+1],point.x=numbers[j+2],point.y=numbers[j+3],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"Q":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=4)path.quadraticCurveTo(numbers[j+0],numbers[j+1],numbers[j+2],numbers[j+3]),control.x=numbers[j+0],control.y=numbers[j+1],point.x=numbers[j+2],point.y=numbers[j+3],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"T":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2){const rx=getReflection(point.x,control.x),ry=getReflection(point.y,control.y);path.quadraticCurveTo(rx,ry,numbers[j+0],numbers[j+1]),control.x=rx,control.y=ry,point.x=numbers[j+0],point.y=numbers[j+1],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case"A":numbers=parseFloats(data,[3,4],7);for(let j=0,jl=numbers.length;j<jl;j+=7){if(numbers[j+5]==point.x&&numbers[j+6]==point.y)continue;const start=point.clone();point.x=numbers[j+5],point.y=numbers[j+6],control.x=point.x,control.y=point.y,parseArcCommand(path,numbers[j],numbers[j+1],numbers[j+2],numbers[j+3],numbers[j+4],start,point),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case"m":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2)point.x+=numbers[j+0],point.y+=numbers[j+1],control.x=point.x,control.y=point.y,0===j?path.moveTo(point.x,point.y):path.lineTo(point.x,point.y),0===j&&firstPoint.copy(point);break;case"h":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j++)point.x+=numbers[j],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"v":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j++)point.y+=numbers[j],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"l":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2)point.x+=numbers[j+0],point.y+=numbers[j+1],control.x=point.x,control.y=point.y,path.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"c":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=6)path.bezierCurveTo(point.x+numbers[j+0],point.y+numbers[j+1],point.x+numbers[j+2],point.y+numbers[j+3],point.x+numbers[j+4],point.y+numbers[j+5]),control.x=point.x+numbers[j+2],control.y=point.y+numbers[j+3],point.x+=numbers[j+4],point.y+=numbers[j+5],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"s":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=4)path.bezierCurveTo(getReflection(point.x,control.x),getReflection(point.y,control.y),point.x+numbers[j+0],point.y+numbers[j+1],point.x+numbers[j+2],point.y+numbers[j+3]),control.x=point.x+numbers[j+0],control.y=point.y+numbers[j+1],point.x+=numbers[j+2],point.y+=numbers[j+3],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"q":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=4)path.quadraticCurveTo(point.x+numbers[j+0],point.y+numbers[j+1],point.x+numbers[j+2],point.y+numbers[j+3]),control.x=point.x+numbers[j+0],control.y=point.y+numbers[j+1],point.x+=numbers[j+2],point.y+=numbers[j+3],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case"t":numbers=parseFloats(data);for(let j=0,jl=numbers.length;j<jl;j+=2){const rx=getReflection(point.x,control.x),ry=getReflection(point.y,control.y);path.quadraticCurveTo(rx,ry,point.x+numbers[j+0],point.y+numbers[j+1]),control.x=rx,control.y=ry,point.x=point.x+numbers[j+0],point.y=point.y+numbers[j+1],0===j&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case"a":numbers=parseFloats(data,[3,4],7);for(let j=0,jl=numbers.length;j<jl;j+=7){if(0==numbers[j+5]&&0==numbers[j+6])continue;const start=point.clone();point.x+=numbers[j+5],point.y+=numbers[j+6],control.x=point.x,control.y=point.y,parseArcCommand(path,numbers[j],numbers[j+1],numbers[j+2],numbers[j+3],numbers[j+4],start,point),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case"Z":case"z":path.currentPath.autoClose=!0,path.currentPath.curves.length>0&&(point.copy(firstPoint),path.currentPath.currentPoint.copy(point),isFirstPoint=!0);break;default:console.warn(command)}doSetFirstPoint=!1}return path}(node));break;case"rect":style=parseStyle(node,style),path=function parseRectNode(node){const x=parseFloatWithUnits(node.getAttribute("x")||0),y=parseFloatWithUnits(node.getAttribute("y")||0),rx=parseFloatWithUnits(node.getAttribute("rx")||node.getAttribute("ry")||0),ry=parseFloatWithUnits(node.getAttribute("ry")||node.getAttribute("rx")||0),w=parseFloatWithUnits(node.getAttribute("width")),h=parseFloatWithUnits(node.getAttribute("height")),bci=.448084975506,path=new three_module.Lc;path.moveTo(x+rx,y),path.lineTo(x+w-rx,y),(0!==rx||0!==ry)&&path.bezierCurveTo(x+w-rx*bci,y,x+w,y+ry*bci,x+w,y+ry);path.lineTo(x+w,y+h-ry),(0!==rx||0!==ry)&&path.bezierCurveTo(x+w,y+h-ry*bci,x+w-rx*bci,y+h,x+w-rx,y+h);path.lineTo(x+rx,y+h),(0!==rx||0!==ry)&&path.bezierCurveTo(x+rx*bci,y+h,x,y+h-ry*bci,x,y+h-ry);path.lineTo(x,y+ry),(0!==rx||0!==ry)&&path.bezierCurveTo(x,y+ry*bci,x+rx*bci,y,x+rx,y);return path}(node);break;case"polygon":style=parseStyle(node,style),path=function parsePolygonNode(node){function iterator(match,a,b){const x=parseFloatWithUnits(a),y=parseFloatWithUnits(b);0===index?path.moveTo(x,y):path.lineTo(x,y),index++}const regex=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,path=new three_module.Lc;let index=0;return node.getAttribute("points").replace(regex,iterator),path.currentPath.autoClose=!0,path}(node);break;case"polyline":style=parseStyle(node,style),path=function parsePolylineNode(node){function iterator(match,a,b){const x=parseFloatWithUnits(a),y=parseFloatWithUnits(b);0===index?path.moveTo(x,y):path.lineTo(x,y),index++}const regex=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,path=new three_module.Lc;let index=0;return node.getAttribute("points").replace(regex,iterator),path.currentPath.autoClose=!1,path}(node);break;case"circle":style=parseStyle(node,style),path=function parseCircleNode(node){const x=parseFloatWithUnits(node.getAttribute("cx")||0),y=parseFloatWithUnits(node.getAttribute("cy")||0),r=parseFloatWithUnits(node.getAttribute("r")||0),subpath=new three_module.kc;subpath.absarc(x,y,r,0,2*Math.PI);const path=new three_module.Lc;return path.subPaths.push(subpath),path}(node);break;case"ellipse":style=parseStyle(node,style),path=function parseEllipseNode(node){const x=parseFloatWithUnits(node.getAttribute("cx")||0),y=parseFloatWithUnits(node.getAttribute("cy")||0),rx=parseFloatWithUnits(node.getAttribute("rx")||0),ry=parseFloatWithUnits(node.getAttribute("ry")||0),subpath=new three_module.kc;subpath.absellipse(x,y,rx,ry,0,2*Math.PI);const path=new three_module.Lc;return path.subPaths.push(subpath),path}(node);break;case"line":style=parseStyle(node,style),path=function parseLineNode(node){const x1=parseFloatWithUnits(node.getAttribute("x1")||0),y1=parseFloatWithUnits(node.getAttribute("y1")||0),x2=parseFloatWithUnits(node.getAttribute("x2")||0),y2=parseFloatWithUnits(node.getAttribute("y2")||0),path=new three_module.Lc;return path.moveTo(x1,y1),path.lineTo(x2,y2),path.currentPath.autoClose=!1,path}(node);break;case"defs":isDefsNode=!0;break;case"use":style=parseStyle(node,style);const usedNodeId=(node.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").substring(1),usedNode=node.viewportElement.getElementById(usedNodeId);usedNode?parseNode(usedNode,style):console.warn("SVGLoader: 'use node' references non-existent node id: "+usedNodeId)}path&&(void 0!==style.fill&&"none"!==style.fill&&path.color.setStyle(style.fill),function transformPath(path,m){function transfVec2(v2){tempV3.set(v2.x,v2.y,1).applyMatrix3(m),v2.set(tempV3.x,tempV3.y)}const isRotated=function isTransformRotated(m){return 0!==m.elements[1]||0!==m.elements[3]}(m),subPaths=path.subPaths;for(let i=0,n=subPaths.length;i<n;i++){const curves=subPaths[i].curves;for(let j=0;j<curves.length;j++){const curve=curves[j];curve.isLineCurve?(transfVec2(curve.v1),transfVec2(curve.v2)):curve.isCubicBezierCurve?(transfVec2(curve.v0),transfVec2(curve.v1),transfVec2(curve.v2),transfVec2(curve.v3)):curve.isQuadraticBezierCurve?(transfVec2(curve.v0),transfVec2(curve.v1),transfVec2(curve.v2)):curve.isEllipseCurve&&(isRotated&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),tempV2.set(curve.aX,curve.aY),transfVec2(tempV2),curve.aX=tempV2.x,curve.aY=tempV2.y,curve.xRadius*=getTransformScaleX(m),curve.yRadius*=getTransformScaleY(m))}}}(path,currentTransform),paths.push(path),path.userData={node:node,style:style});const childNodes=node.childNodes;for(let i=0;i<childNodes.length;i++){const node=childNodes[i];isDefsNode&&"style"!==node.nodeName&&"defs"!==node.nodeName||parseNode(node,style)}transform&&(transformStack.pop(),transformStack.length>0?currentTransform.copy(transformStack[transformStack.length-1]):currentTransform.identity())}(xml.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4});return{paths:paths,xml:xml.documentElement}}static createShapes(shapePath){const IntersectionLocationType_ORIGIN=0,IntersectionLocationType_DESTINATION=1,IntersectionLocationType_BETWEEN=2,IntersectionLocationType_LEFT=3,IntersectionLocationType_RIGHT=4,IntersectionLocationType_BEHIND=5,IntersectionLocationType_BEYOND=6,classifyResult={loc:IntersectionLocationType_ORIGIN,t:0};function findEdgeIntersection(a0,a1,b0,b1){const x1=a0.x,x2=a1.x,x3=b0.x,x4=b1.x,y1=a0.y,y2=a1.y,y3=b0.y,y4=b1.y,nom1=(x4-x3)*(y1-y3)-(y4-y3)*(x1-x3),denom=(y4-y3)*(x2-x1)-(x4-x3)*(y2-y1),t1=nom1/denom,t2=((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3))/denom;if(0===denom&&0!==nom1||t1<=0||t1>=1||t2<0||t2>1)return null;if(0===nom1&&0===denom){for(let i=0;i<2;i++){if(classifyPoint(0===i?b0:b1,a0,a1),classifyResult.loc==IntersectionLocationType_ORIGIN){const point=0===i?b0:b1;return{x:point.x,y:point.y,t:classifyResult.t}}if(classifyResult.loc==IntersectionLocationType_BETWEEN){return{x:+(x1+classifyResult.t*(x2-x1)).toPrecision(10),y:+(y1+classifyResult.t*(y2-y1)).toPrecision(10),t:classifyResult.t}}}return null}for(let i=0;i<2;i++)if(classifyPoint(0===i?b0:b1,a0,a1),classifyResult.loc==IntersectionLocationType_ORIGIN){const point=0===i?b0:b1;return{x:point.x,y:point.y,t:classifyResult.t}}return{x:+(x1+t1*(x2-x1)).toPrecision(10),y:+(y1+t1*(y2-y1)).toPrecision(10),t:t1}}function classifyPoint(p,edgeStart,edgeEnd){const ax=edgeEnd.x-edgeStart.x,ay=edgeEnd.y-edgeStart.y,bx=p.x-edgeStart.x,by=p.y-edgeStart.y,sa=ax*by-bx*ay;if(p.x===edgeStart.x&&p.y===edgeStart.y)return classifyResult.loc=IntersectionLocationType_ORIGIN,void(classifyResult.t=0);if(p.x===edgeEnd.x&&p.y===edgeEnd.y)return classifyResult.loc=IntersectionLocationType_DESTINATION,void(classifyResult.t=1);if(sa<-Number.EPSILON)return void(classifyResult.loc=IntersectionLocationType_LEFT);if(sa>Number.EPSILON)return void(classifyResult.loc=IntersectionLocationType_RIGHT);if(ax*bx<0||ay*by<0)return void(classifyResult.loc=IntersectionLocationType_BEHIND);if(Math.sqrt(ax*ax+ay*ay)<Math.sqrt(bx*bx+by*by))return void(classifyResult.loc=IntersectionLocationType_BEYOND);let t;t=0!==ax?bx/ax:by/ay,classifyResult.loc=IntersectionLocationType_BETWEEN,classifyResult.t=t}function getScanlineIntersections(scanline,boundingBox,paths){const center=new three_module.td;boundingBox.getCenter(center);const allIntersections=[];return paths.forEach((path=>{if(path.boundingBox.containsPoint(center)){(function getIntersections(path1,path2){const intersectionsRaw=[],intersections=[];for(let index=1;index<path1.length;index++){const path1EdgeStart=path1[index-1],path1EdgeEnd=path1[index];for(let index2=1;index2<path2.length;index2++){const intersection=findEdgeIntersection(path1EdgeStart,path1EdgeEnd,path2[index2-1],path2[index2]);null!==intersection&&void 0===intersectionsRaw.find((i=>i.t<=intersection.t+Number.EPSILON&&i.t>=intersection.t-Number.EPSILON))&&(intersectionsRaw.push(intersection),intersections.push(new three_module.td(intersection.x,intersection.y)))}}return intersections})(scanline,path.points).forEach((p=>{allIntersections.push({identifier:path.identifier,isCW:path.isCW,point:p})}))}})),allIntersections.sort(((i1,i2)=>i1.point.x-i2.point.x)),allIntersections}let identifier=0,scanlineMinX=999999999,scanlineMaxX=-999999999,simplePaths=shapePath.subPaths.map((p=>{const points=p.getPoints();let maxY=-999999999,minY=999999999,maxX=-999999999,minX=999999999;for(let i=0;i<points.length;i++){const p=points[i];p.y>maxY&&(maxY=p.y),p.y<minY&&(minY=p.y),p.x>maxX&&(maxX=p.x),p.x<minX&&(minX=p.x)}return scanlineMaxX<=maxX&&(scanlineMaxX=maxX+1),scanlineMinX>=minX&&(scanlineMinX=minX-1),{curves:p.curves,points:points,isCW:three_module.Mc.isClockWise(points),identifier:identifier++,boundingBox:new three_module.j(new three_module.td(minX,minY),new three_module.td(maxX,maxY))}}));simplePaths=simplePaths.filter((sp=>sp.points.length>1));const isAHole=simplePaths.map((p=>function isHoleTo(simplePath,allPaths,scanlineMinX,scanlineMaxX,_fillRule){null!=_fillRule&&""!==_fillRule||(_fillRule="nonzero");const centerBoundingBox=new three_module.td;simplePath.boundingBox.getCenter(centerBoundingBox);const scanlineIntersections=getScanlineIntersections([new three_module.td(scanlineMinX,centerBoundingBox.y),new three_module.td(scanlineMaxX,centerBoundingBox.y)],simplePath.boundingBox,allPaths);scanlineIntersections.sort(((i1,i2)=>i1.point.x-i2.point.x));const baseIntersections=[],otherIntersections=[];scanlineIntersections.forEach((i=>{i.identifier===simplePath.identifier?baseIntersections.push(i):otherIntersections.push(i)}));const firstXOfPath=baseIntersections[0].point.x,stack=[];let i=0;for(;i<otherIntersections.length&&otherIntersections[i].point.x<firstXOfPath;)stack.length>0&&stack[stack.length-1]===otherIntersections[i].identifier?stack.pop():stack.push(otherIntersections[i].identifier),i++;if(stack.push(simplePath.identifier),"evenodd"===_fillRule){const isHole=stack.length%2==0,isHoleFor=stack[stack.length-2];return{identifier:simplePath.identifier,isHole:isHole,for:isHoleFor}}if("nonzero"===_fillRule){let isHole=!0,isHoleFor=null,lastCWValue=null;for(let i=0;i<stack.length;i++){const identifier=stack[i];isHole?(lastCWValue=allPaths[identifier].isCW,isHole=!1,isHoleFor=identifier):lastCWValue!==allPaths[identifier].isCW&&(lastCWValue=allPaths[identifier].isCW,isHole=!0)}return{identifier:simplePath.identifier,isHole:isHole,for:isHoleFor}}console.warn('fill-rule: "'+_fillRule+'" is currently not implemented.')}(p,simplePaths,scanlineMinX,scanlineMaxX,shapePath.userData.style.fillRule))),shapesToReturn=[];return simplePaths.forEach((p=>{if(!isAHole[p.identifier].isHole){const shape=new three_module.Kc;shape.curves=p.curves;isAHole.filter((h=>h.isHole&&h.for===p.identifier)).forEach((h=>{const hole=simplePaths[h.identifier],path=new three_module.kc;path.curves=hole.curves,shape.holes.push(path)})),shapesToReturn.push(shape)}})),shapesToReturn}static getStrokeStyle(width,color,lineJoin,lineCap,miterLimit){return{strokeColor:color=void 0!==color?color:"#000",strokeWidth:width=void 0!==width?width:1,strokeLineJoin:lineJoin=void 0!==lineJoin?lineJoin:"miter",strokeLineCap:lineCap=void 0!==lineCap?lineCap:"butt",strokeMiterLimit:miterLimit=void 0!==miterLimit?miterLimit:4}}static pointsToStroke(points,style,arcDivisions,minDistance){const vertices=[],normals=[],uvs=[];if(0===SVGLoader_SVGLoader.pointsToStrokeWithBuffers(points,style,arcDivisions,minDistance,vertices,normals,uvs))return null;const geometry=new three_module.p;return geometry.setAttribute("position",new three_module.V(vertices,3)),geometry.setAttribute("normal",new three_module.V(normals,3)),geometry.setAttribute("uv",new three_module.V(uvs,2)),geometry}static pointsToStrokeWithBuffers(points,style,arcDivisions,minDistance,vertices,normals,uvs,vertexOffset){const tempV2_1=new three_module.td,tempV2_2=new three_module.td,tempV2_3=new three_module.td,tempV2_4=new three_module.td,tempV2_5=new three_module.td,tempV2_6=new three_module.td,tempV2_7=new three_module.td,lastPointL=new three_module.td,lastPointR=new three_module.td,point0L=new three_module.td,point0R=new three_module.td,currentPointL=new three_module.td,currentPointR=new three_module.td,nextPointL=new three_module.td,nextPointR=new three_module.td,innerPoint=new three_module.td,outerPoint=new three_module.td;arcDivisions=void 0!==arcDivisions?arcDivisions:12,minDistance=void 0!==minDistance?minDistance:.001,vertexOffset=void 0!==vertexOffset?vertexOffset:0;const numPoints=(points=function removeDuplicatedPoints(points){let dupPoints=!1;for(let i=1,n=points.length-1;i<n;i++)if(points[i].distanceTo(points[i+1])<minDistance){dupPoints=!0;break}if(!dupPoints)return points;const newPoints=[];newPoints.push(points[0]);for(let i=1,n=points.length-1;i<n;i++)points[i].distanceTo(points[i+1])>=minDistance&&newPoints.push(points[i]);return newPoints.push(points[points.length-1]),newPoints}(points)).length;if(numPoints<2)return 0;const isClosed=points[0].equals(points[numPoints-1]);let currentPoint,nextPoint,previousPoint=points[0];const strokeWidth2=style.strokeWidth/2,deltaU=1/(numPoints-1);let u1,innerSideModified,joinIsOnLeftSide,isMiter,u0=0,initialJoinIsOnLeftSide=!1,numVertices=0,currentCoordinate=3*vertexOffset,currentCoordinateUV=2*vertexOffset;getNormal(points[0],points[1],tempV2_1).multiplyScalar(strokeWidth2),lastPointL.copy(points[0]).sub(tempV2_1),lastPointR.copy(points[0]).add(tempV2_1),point0L.copy(lastPointL),point0R.copy(lastPointR);for(let iPoint=1;iPoint<numPoints;iPoint++){currentPoint=points[iPoint],nextPoint=iPoint===numPoints-1?isClosed?points[1]:void 0:points[iPoint+1];const normal1=tempV2_1;if(getNormal(previousPoint,currentPoint,normal1),tempV2_3.copy(normal1).multiplyScalar(strokeWidth2),currentPointL.copy(currentPoint).sub(tempV2_3),currentPointR.copy(currentPoint).add(tempV2_3),u1=u0+deltaU,innerSideModified=!1,void 0!==nextPoint){getNormal(currentPoint,nextPoint,tempV2_2),tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2),nextPointL.copy(currentPoint).sub(tempV2_3),nextPointR.copy(currentPoint).add(tempV2_3),joinIsOnLeftSide=!0,tempV2_3.subVectors(nextPoint,previousPoint),normal1.dot(tempV2_3)<0&&(joinIsOnLeftSide=!1),1===iPoint&&(initialJoinIsOnLeftSide=joinIsOnLeftSide),tempV2_3.subVectors(nextPoint,currentPoint),tempV2_3.normalize();const dot=Math.abs(normal1.dot(tempV2_3));if(0!==dot){const miterSide=strokeWidth2/dot;tempV2_3.multiplyScalar(-miterSide),tempV2_4.subVectors(currentPoint,previousPoint),tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3),innerPoint.copy(tempV2_5).negate();const miterLength2=tempV2_5.length(),segmentLengthPrev=tempV2_4.length();tempV2_4.divideScalar(segmentLengthPrev),tempV2_6.subVectors(nextPoint,currentPoint);const segmentLengthNext=tempV2_6.length();switch(tempV2_6.divideScalar(segmentLengthNext),tempV2_4.dot(innerPoint)<segmentLengthPrev&&tempV2_6.dot(innerPoint)<segmentLengthNext&&(innerSideModified=!0),outerPoint.copy(tempV2_5).add(currentPoint),innerPoint.add(currentPoint),isMiter=!1,innerSideModified?joinIsOnLeftSide?(nextPointR.copy(innerPoint),currentPointR.copy(innerPoint)):(nextPointL.copy(innerPoint),currentPointL.copy(innerPoint)):makeSegmentTriangles(),style.strokeLineJoin){case"bevel":makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u1);break;case"round":createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified),joinIsOnLeftSide?makeCircularSector(currentPoint,currentPointL,nextPointL,u1,0):makeCircularSector(currentPoint,nextPointR,currentPointR,u1,1);break;default:const miterFraction=strokeWidth2*style.strokeMiterLimit/miterLength2;if(miterFraction<1){if("miter-clip"!==style.strokeLineJoin){makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u1);break}createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified),joinIsOnLeftSide?(tempV2_6.subVectors(outerPoint,currentPointL).multiplyScalar(miterFraction).add(currentPointL),tempV2_7.subVectors(outerPoint,nextPointL).multiplyScalar(miterFraction).add(nextPointL),addVertex(currentPointL,u1,0),addVertex(tempV2_6,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(tempV2_6,u1,0),addVertex(tempV2_7,u1,0),addVertex(currentPoint,u1,.5),addVertex(tempV2_7,u1,0),addVertex(nextPointL,u1,0)):(tempV2_6.subVectors(outerPoint,currentPointR).multiplyScalar(miterFraction).add(currentPointR),tempV2_7.subVectors(outerPoint,nextPointR).multiplyScalar(miterFraction).add(nextPointR),addVertex(currentPointR,u1,1),addVertex(tempV2_6,u1,1),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(tempV2_6,u1,1),addVertex(tempV2_7,u1,1),addVertex(currentPoint,u1,.5),addVertex(tempV2_7,u1,1),addVertex(nextPointR,u1,1))}else innerSideModified?(joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(outerPoint,u1,0),addVertex(lastPointR,u0,1),addVertex(outerPoint,u1,0),addVertex(innerPoint,u1,1)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(outerPoint,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(outerPoint,u1,1)),joinIsOnLeftSide?nextPointL.copy(outerPoint):nextPointR.copy(outerPoint)):joinIsOnLeftSide?(addVertex(currentPointL,u1,0),addVertex(outerPoint,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(outerPoint,u1,0),addVertex(nextPointL,u1,0)):(addVertex(currentPointR,u1,1),addVertex(outerPoint,u1,1),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(outerPoint,u1,1),addVertex(nextPointR,u1,1)),isMiter=!0}}else makeSegmentTriangles()}else makeSegmentTriangles();isClosed||iPoint!==numPoints-1||addCapGeometry(points[0],point0L,point0R,joinIsOnLeftSide,!0,u0),u0=u1,previousPoint=currentPoint,lastPointL.copy(nextPointL),lastPointR.copy(nextPointR)}if(isClosed){if(innerSideModified&&vertices){let lastOuter=outerPoint,lastInner=innerPoint;initialJoinIsOnLeftSide!==joinIsOnLeftSide&&(lastOuter=innerPoint,lastInner=outerPoint),joinIsOnLeftSide?(isMiter||initialJoinIsOnLeftSide)&&(lastInner.toArray(vertices,0),lastInner.toArray(vertices,9),isMiter&&lastOuter.toArray(vertices,3)):!isMiter&&initialJoinIsOnLeftSide||(lastInner.toArray(vertices,3),lastInner.toArray(vertices,9),isMiter&&lastOuter.toArray(vertices,0))}}else addCapGeometry(currentPoint,currentPointL,currentPointR,joinIsOnLeftSide,!1,u1);return numVertices;function getNormal(p1,p2,result){return result.subVectors(p2,p1),result.set(-result.y,result.x).normalize()}function addVertex(position,u,v){vertices&&(vertices[currentCoordinate]=position.x,vertices[currentCoordinate+1]=position.y,vertices[currentCoordinate+2]=0,normals&&(normals[currentCoordinate]=0,normals[currentCoordinate+1]=0,normals[currentCoordinate+2]=1),currentCoordinate+=3,uvs&&(uvs[currentCoordinateUV]=u,uvs[currentCoordinateUV+1]=v,currentCoordinateUV+=2)),numVertices+=3}function makeCircularSector(center,p1,p2,u,v){tempV2_1.copy(p1).sub(center).normalize(),tempV2_2.copy(p2).sub(center).normalize();let angle=Math.PI;const dot=tempV2_1.dot(tempV2_2);Math.abs(dot)<1&&(angle=Math.abs(Math.acos(dot))),angle/=arcDivisions,tempV2_3.copy(p1);for(let i=0,il=arcDivisions-1;i<il;i++)tempV2_4.copy(tempV2_3).rotateAround(center,angle),addVertex(tempV2_3,u,v),addVertex(tempV2_4,u,v),addVertex(center,u,.5),tempV2_3.copy(tempV2_4);addVertex(tempV2_4,u,v),addVertex(p2,u,v),addVertex(center,u,.5)}function makeSegmentTriangles(){addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,1),addVertex(currentPointR,u1,0)}function makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u){innerSideModified?joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,0),addVertex(innerPoint,u1,1),addVertex(currentPointL,u,0),addVertex(nextPointL,u,0),addVertex(innerPoint,u,.5)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointR,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(currentPointR,u1,1),addVertex(currentPointR,u,1),addVertex(nextPointR,u,0),addVertex(innerPoint,u,.5)):joinIsOnLeftSide?(addVertex(currentPointL,u,0),addVertex(nextPointL,u,0),addVertex(currentPoint,u,.5)):(addVertex(currentPointR,u,1),addVertex(nextPointR,u,0),addVertex(currentPoint,u,.5))}function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified){innerSideModified&&(joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,0),addVertex(innerPoint,u1,1),addVertex(currentPointL,u0,0),addVertex(currentPoint,u1,.5),addVertex(innerPoint,u1,1),addVertex(currentPoint,u1,.5),addVertex(nextPointL,u0,0),addVertex(innerPoint,u1,1)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointR,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(currentPointR,u1,1),addVertex(currentPointR,u0,1),addVertex(innerPoint,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(innerPoint,u1,0),addVertex(nextPointR,u0,1)))}function addCapGeometry(center,p1,p2,joinIsOnLeftSide,start,u){switch(style.strokeLineCap){case"round":start?makeCircularSector(center,p2,p1,u,.5):makeCircularSector(center,p1,p2,u,.5);break;case"square":if(start)tempV2_1.subVectors(p1,center),tempV2_2.set(tempV2_1.y,-tempV2_1.x),tempV2_3.addVectors(tempV2_1,tempV2_2).add(center),tempV2_4.subVectors(tempV2_2,tempV2_1).add(center),joinIsOnLeftSide?(tempV2_3.toArray(vertices,3),tempV2_4.toArray(vertices,0),tempV2_4.toArray(vertices,9)):(tempV2_3.toArray(vertices,3),tempV2_3.toArray(vertices,9),tempV2_4.toArray(vertices,0));else{tempV2_1.subVectors(p2,center),tempV2_2.set(tempV2_1.y,-tempV2_1.x),tempV2_3.addVectors(tempV2_1,tempV2_2).add(center),tempV2_4.subVectors(tempV2_2,tempV2_1).add(center);const vl=vertices.length;joinIsOnLeftSide?(tempV2_3.toArray(vertices,vl-3),tempV2_4.toArray(vertices,vl-6),tempV2_4.toArray(vertices,vl-12)):(tempV2_3.toArray(vertices,vl-6),tempV2_4.toArray(vertices,vl-3),tempV2_4.toArray(vertices,vl-12))}}}}}var lib=__webpack_require__("./node_modules/@lincode/utils/lib/index.js"),useLoadingCount=__webpack_require__("./node_modules/lingo3d/lib/states/useLoadingCount.js"),bytesLoaded=__webpack_require__("./node_modules/lingo3d/lib/display/utils/loaders/bytesLoaded.js");const cache=new Map,loadSVG_loader=new SVGLoader_SVGLoader;__webpack_exports__.default=url=>Object(lib.e)(cache,url,(()=>new Promise(((resolve,reject)=>{Object(useLoadingCount.c)(),loadSVG_loader.load(url,(svg=>{Object(useLoadingCount.a)(),resolve(Object.freeze(svg))}),bytesLoaded.b,(()=>{Object(useLoadingCount.a)(),reject()}))}))))}}]);