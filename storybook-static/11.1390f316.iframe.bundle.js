(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{"./node_modules/lingo3d/lib/display/utils/cloneSkinnedMesh.js":function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__("./node_modules/three/build/three.module.js");function SkeletonUtils_clone(source){const sourceLookup=new Map,cloneLookup=new Map,clone=source.clone();return parallelTraverse(source,clone,(function(sourceNode,clonedNode){sourceLookup.set(clonedNode,sourceNode),cloneLookup.set(sourceNode,clonedNode)})),clone.traverse((function(node){if(!node.isSkinnedMesh)return;const clonedMesh=node,sourceMesh=sourceLookup.get(node),sourceBones=sourceMesh.skeleton.bones;clonedMesh.skeleton=sourceMesh.skeleton.clone(),clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix),clonedMesh.skeleton.bones=sourceBones.map((function(bone){return cloneLookup.get(bone)})),clonedMesh.bind(clonedMesh.skeleton,clonedMesh.bindMatrix)})),clone}function parallelTraverse(a,b,callback){callback(a,b);for(let i=0;i<a.children.length;i++)parallelTraverse(a.children[i],b.children[i],callback)}__webpack_exports__.a=(target,animations=target.animations)=>{const clone=SkeletonUtils_clone(target);return clone.animations=animations,clone}},"./node_modules/lingo3d/lib/display/utils/loaders/loadGLTF.js":function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);var three_module=__webpack_require__("./node_modules/three/build/three.module.js");class GLTFLoader_GLTFLoader extends three_module.Ab{constructor(manager){super(manager),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(parser){return new GLTFLoader_GLTFMaterialsClearcoatExtension(parser)})),this.register((function(parser){return new GLTFTextureBasisUExtension(parser)})),this.register((function(parser){return new GLTFTextureWebPExtension(parser)})),this.register((function(parser){return new GLTFLoader_GLTFMaterialsSheenExtension(parser)})),this.register((function(parser){return new GLTFLoader_GLTFMaterialsTransmissionExtension(parser)})),this.register((function(parser){return new GLTFLoader_GLTFMaterialsVolumeExtension(parser)})),this.register((function(parser){return new GLTFLoader_GLTFMaterialsIorExtension(parser)})),this.register((function(parser){return new GLTFMaterialsEmissiveStrengthExtension(parser)})),this.register((function(parser){return new GLTFLoader_GLTFMaterialsSpecularExtension(parser)})),this.register((function(parser){return new GLTFLoader_GLTFLightsExtension(parser)})),this.register((function(parser){return new GLTFMeshoptCompression(parser)}))}load(url,onLoad,onProgress,onError){const scope=this;let resourcePath;resourcePath=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:three_module.Bb.extractUrlBase(url),this.manager.itemStart(url);const _onError=function(e){onError?onError(e):console.error(e),scope.manager.itemError(url),scope.manager.itemEnd(url)},loader=new three_module.U(this.manager);loader.setPath(this.path),loader.setResponseType("arraybuffer"),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,(function(data){try{scope.parse(data,resourcePath,(function(gltf){onLoad(gltf),scope.manager.itemEnd(url)}),_onError)}catch(e){_onError(e)}}),onProgress,_onError)}setDRACOLoader(dracoLoader){return this.dracoLoader=dracoLoader,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(ktx2Loader){return this.ktx2Loader=ktx2Loader,this}setMeshoptDecoder(meshoptDecoder){return this.meshoptDecoder=meshoptDecoder,this}register(callback){return-1===this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.push(callback),this}unregister(callback){return-1!==this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback),1),this}parse(data,path,onLoad,onError){let content;const extensions={},plugins={};if("string"==typeof data)content=data;else{if(three_module.Bb.decodeText(new Uint8Array(data,0,4))===BINARY_EXTENSION_HEADER_MAGIC){try{extensions[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFLoader_GLTFBinaryExtension(data)}catch(error){return void(onError&&onError(error))}content=extensions[EXTENSIONS.KHR_BINARY_GLTF].content}else content=three_module.Bb.decodeText(new Uint8Array(data))}const json=JSON.parse(content);if(void 0===json.asset||json.asset.version[0]<2)return void(onError&&onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const parser=new GLTFLoader_GLTFParser(json,{path:path||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});parser.fileLoader.setRequestHeader(this.requestHeader);for(let i=0;i<this.pluginCallbacks.length;i++){const plugin=this.pluginCallbacks[i](parser);plugins[plugin.name]=plugin,extensions[plugin.name]=!0}if(json.extensionsUsed)for(let i=0;i<json.extensionsUsed.length;++i){const extensionName=json.extensionsUsed[i],extensionsRequired=json.extensionsRequired||[];switch(extensionName){case EXTENSIONS.KHR_MATERIALS_UNLIT:extensions[extensionName]=new GLTFLoader_GLTFMaterialsUnlitExtension;break;case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:extensions[extensionName]=new GLTFLoader_GLTFMaterialsPbrSpecularGlossinessExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:extensions[extensionName]=new GLTFDracoMeshCompressionExtension(json,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:extensions[extensionName]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:extensions[extensionName]=new GLTFMeshQuantizationExtension;break;default:extensionsRequired.indexOf(extensionName)>=0&&void 0===plugins[extensionName]&&console.warn('THREE.GLTFLoader: Unknown extension "'+extensionName+'".')}}parser.setExtensions(extensions),parser.setPlugins(plugins),parser.parse(onLoad,onError)}parseAsync(data,path){const scope=this;return new Promise((function(resolve,reject){scope.parse(data,path,resolve,reject)}))}}function GLTFRegistry(){let objects={};return{get:function(key){return objects[key]},add:function(key,object){objects[key]=object},remove:function(key){delete objects[key]},removeAll:function(){objects={}}}}const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class GLTFLoader_GLTFLightsExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const parser=this.parser,nodeDefs=this.parser.json.nodes||[];for(let nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++){const nodeDef=nodeDefs[nodeIndex];nodeDef.extensions&&nodeDef.extensions[this.name]&&void 0!==nodeDef.extensions[this.name].light&&parser._addNodeRef(this.cache,nodeDef.extensions[this.name].light)}}_loadLight(lightIndex){const parser=this.parser,cacheKey="light:"+lightIndex;let dependency=parser.cache.get(cacheKey);if(dependency)return dependency;const json=parser.json,lightDef=((json.extensions&&json.extensions[this.name]||{}).lights||[])[lightIndex];let lightNode;const color=new three_module.w(16777215);void 0!==lightDef.color&&color.fromArray(lightDef.color);const range=void 0!==lightDef.range?lightDef.range:0;switch(lightDef.type){case"directional":lightNode=new three_module.K(color),lightNode.target.position.set(0,0,-1),lightNode.add(lightNode.target);break;case"point":lightNode=new three_module.pc(color),lightNode.distance=range;break;case"spot":lightNode=new three_module.Vc(color),lightNode.distance=range,lightDef.spot=lightDef.spot||{},lightDef.spot.innerConeAngle=void 0!==lightDef.spot.innerConeAngle?lightDef.spot.innerConeAngle:0,lightDef.spot.outerConeAngle=void 0!==lightDef.spot.outerConeAngle?lightDef.spot.outerConeAngle:Math.PI/4,lightNode.angle=lightDef.spot.outerConeAngle,lightNode.penumbra=1-lightDef.spot.innerConeAngle/lightDef.spot.outerConeAngle,lightNode.target.position.set(0,0,-1),lightNode.add(lightNode.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+lightDef.type)}return lightNode.position.set(0,0,0),lightNode.decay=2,void 0!==lightDef.intensity&&(lightNode.intensity=lightDef.intensity),lightNode.name=parser.createUniqueName(lightDef.name||"light_"+lightIndex),dependency=Promise.resolve(lightNode),parser.cache.add(cacheKey,dependency),dependency}createNodeAttachment(nodeIndex){const self=this,parser=this.parser,nodeDef=parser.json.nodes[nodeIndex],lightIndex=(nodeDef.extensions&&nodeDef.extensions[this.name]||{}).light;return void 0===lightIndex?null:this._loadLight(lightIndex).then((function(light){return parser._getNodeRef(self.cache,lightIndex,light)}))}}class GLTFLoader_GLTFMaterialsUnlitExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return three_module.Mb}extendParams(materialParams,materialDef,parser){const pending=[];materialParams.color=new three_module.w(1,1,1),materialParams.opacity=1;const metallicRoughness=materialDef.pbrMetallicRoughness;if(metallicRoughness){if(Array.isArray(metallicRoughness.baseColorFactor)){const array=metallicRoughness.baseColorFactor;materialParams.color.fromArray(array),materialParams.opacity=array[3]}void 0!==metallicRoughness.baseColorTexture&&pending.push(parser.assignTexture(materialParams,"map",metallicRoughness.baseColorTexture,three_module.Cd))}return Promise.all(pending)}}class GLTFMaterialsEmissiveStrengthExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(materialIndex,materialParams){const materialDef=this.parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const emissiveStrength=materialDef.extensions[this.name].emissiveStrength;return void 0!==emissiveStrength&&(materialParams.emissiveIntensity=emissiveStrength),Promise.resolve()}}class GLTFLoader_GLTFMaterialsClearcoatExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return materialDef.extensions&&materialDef.extensions[this.name]?three_module.Rb:null}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];if(void 0!==extension.clearcoatFactor&&(materialParams.clearcoat=extension.clearcoatFactor),void 0!==extension.clearcoatTexture&&pending.push(parser.assignTexture(materialParams,"clearcoatMap",extension.clearcoatTexture)),void 0!==extension.clearcoatRoughnessFactor&&(materialParams.clearcoatRoughness=extension.clearcoatRoughnessFactor),void 0!==extension.clearcoatRoughnessTexture&&pending.push(parser.assignTexture(materialParams,"clearcoatRoughnessMap",extension.clearcoatRoughnessTexture)),void 0!==extension.clearcoatNormalTexture&&(pending.push(parser.assignTexture(materialParams,"clearcoatNormalMap",extension.clearcoatNormalTexture)),void 0!==extension.clearcoatNormalTexture.scale)){const scale=extension.clearcoatNormalTexture.scale;materialParams.clearcoatNormalScale=new three_module.td(scale,scale)}return Promise.all(pending)}}class GLTFLoader_GLTFMaterialsSheenExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return materialDef.extensions&&materialDef.extensions[this.name]?three_module.Rb:null}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[];materialParams.sheenColor=new three_module.w(0,0,0),materialParams.sheenRoughness=0,materialParams.sheen=1;const extension=materialDef.extensions[this.name];return void 0!==extension.sheenColorFactor&&materialParams.sheenColor.fromArray(extension.sheenColorFactor),void 0!==extension.sheenRoughnessFactor&&(materialParams.sheenRoughness=extension.sheenRoughnessFactor),void 0!==extension.sheenColorTexture&&pending.push(parser.assignTexture(materialParams,"sheenColorMap",extension.sheenColorTexture,three_module.Cd)),void 0!==extension.sheenRoughnessTexture&&pending.push(parser.assignTexture(materialParams,"sheenRoughnessMap",extension.sheenRoughnessTexture)),Promise.all(pending)}}class GLTFLoader_GLTFMaterialsTransmissionExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return materialDef.extensions&&materialDef.extensions[this.name]?three_module.Rb:null}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];return void 0!==extension.transmissionFactor&&(materialParams.transmission=extension.transmissionFactor),void 0!==extension.transmissionTexture&&pending.push(parser.assignTexture(materialParams,"transmissionMap",extension.transmissionTexture)),Promise.all(pending)}}class GLTFLoader_GLTFMaterialsVolumeExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return materialDef.extensions&&materialDef.extensions[this.name]?three_module.Rb:null}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];materialParams.thickness=void 0!==extension.thicknessFactor?extension.thicknessFactor:0,void 0!==extension.thicknessTexture&&pending.push(parser.assignTexture(materialParams,"thicknessMap",extension.thicknessTexture)),materialParams.attenuationDistance=extension.attenuationDistance||0;const colorArray=extension.attenuationColor||[1,1,1];return materialParams.attenuationColor=new three_module.w(colorArray[0],colorArray[1],colorArray[2]),Promise.all(pending)}}class GLTFLoader_GLTFMaterialsIorExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return materialDef.extensions&&materialDef.extensions[this.name]?three_module.Rb:null}extendMaterialParams(materialIndex,materialParams){const materialDef=this.parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const extension=materialDef.extensions[this.name];return materialParams.ior=void 0!==extension.ior?extension.ior:1.5,Promise.resolve()}}class GLTFLoader_GLTFMaterialsSpecularExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return materialDef.extensions&&materialDef.extensions[this.name]?three_module.Rb:null}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];materialParams.specularIntensity=void 0!==extension.specularFactor?extension.specularFactor:1,void 0!==extension.specularTexture&&pending.push(parser.assignTexture(materialParams,"specularIntensityMap",extension.specularTexture));const colorArray=extension.specularColorFactor||[1,1,1];return materialParams.specularColor=new three_module.w(colorArray[0],colorArray[1],colorArray[2]),void 0!==extension.specularColorTexture&&pending.push(parser.assignTexture(materialParams,"specularColorMap",extension.specularColorTexture,three_module.Cd)),Promise.all(pending)}}class GLTFTextureBasisUExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(textureIndex){const parser=this.parser,json=parser.json,textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[this.name])return null;const extension=textureDef.extensions[this.name],loader=parser.options.ktx2Loader;if(!loader){if(json.extensionsRequired&&json.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return parser.loadTextureImage(textureIndex,extension.source,loader)}}class GLTFTextureWebPExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(textureIndex){const name=this.name,parser=this.parser,json=parser.json,textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[name])return null;const extension=textureDef.extensions[name],source=json.images[extension.source];let loader=parser.textureLoader;if(source.uri){const handler=parser.options.manager.getHandler(source.uri);null!==handler&&(loader=handler)}return this.detectSupport().then((function(isSupported){if(isSupported)return parser.loadTextureImage(textureIndex,extension.source,loader);if(json.extensionsRequired&&json.extensionsRequired.indexOf(name)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return parser.loadTexture(textureIndex)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(resolve){const image=new Image;image.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",image.onload=image.onerror=function(){resolve(1===image.height)}}))),this.isSupported}}class GLTFMeshoptCompression{constructor(parser){this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION,this.parser=parser}loadBufferView(index){const json=this.parser.json,bufferView=json.bufferViews[index];if(bufferView.extensions&&bufferView.extensions[this.name]){const extensionDef=bufferView.extensions[this.name],buffer=this.parser.getDependency("buffer",extensionDef.buffer),decoder=this.parser.options.meshoptDecoder;if(!decoder||!decoder.supported){if(json.extensionsRequired&&json.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([buffer,decoder.ready]).then((function(res){const byteOffset=extensionDef.byteOffset||0,byteLength=extensionDef.byteLength||0,count=extensionDef.count,stride=extensionDef.byteStride,result=new ArrayBuffer(count*stride),source=new Uint8Array(res[0],byteOffset,byteLength);return decoder.decodeGltfBuffer(new Uint8Array(result),count,stride,source,extensionDef.mode,extensionDef.filter),result}))}return null}}const BINARY_EXTENSION_HEADER_MAGIC="glTF",BINARY_EXTENSION_CHUNK_TYPES_JSON=1313821514,BINARY_EXTENSION_CHUNK_TYPES_BIN=5130562;class GLTFLoader_GLTFBinaryExtension{constructor(data){this.name=EXTENSIONS.KHR_BINARY_GLTF,this.content=null,this.body=null;const headerView=new DataView(data,0,12);if(this.header={magic:three_module.Bb.decodeText(new Uint8Array(data.slice(0,4))),version:headerView.getUint32(4,!0),length:headerView.getUint32(8,!0)},this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const chunkContentsLength=this.header.length-12,chunkView=new DataView(data,12);let chunkIndex=0;for(;chunkIndex<chunkContentsLength;){const chunkLength=chunkView.getUint32(chunkIndex,!0);chunkIndex+=4;const chunkType=chunkView.getUint32(chunkIndex,!0);if(chunkIndex+=4,chunkType===BINARY_EXTENSION_CHUNK_TYPES_JSON){const contentArray=new Uint8Array(data,12+chunkIndex,chunkLength);this.content=three_module.Bb.decodeText(contentArray)}else if(chunkType===BINARY_EXTENSION_CHUNK_TYPES_BIN){const byteOffset=12+chunkIndex;this.body=data.slice(byteOffset,byteOffset+chunkLength)}chunkIndex+=chunkLength}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(json,dracoLoader){if(!dracoLoader)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,this.json=json,this.dracoLoader=dracoLoader,this.dracoLoader.preload()}decodePrimitive(primitive,parser){const json=this.json,dracoLoader=this.dracoLoader,bufferViewIndex=primitive.extensions[this.name].bufferView,gltfAttributeMap=primitive.extensions[this.name].attributes,threeAttributeMap={},attributeNormalizedMap={},attributeTypeMap={};for(const attributeName in gltfAttributeMap){const threeAttributeName=ATTRIBUTES[attributeName]||attributeName.toLowerCase();threeAttributeMap[threeAttributeName]=gltfAttributeMap[attributeName]}for(const attributeName in primitive.attributes){const threeAttributeName=ATTRIBUTES[attributeName]||attributeName.toLowerCase();if(void 0!==gltfAttributeMap[attributeName]){const accessorDef=json.accessors[primitive.attributes[attributeName]],componentType=WEBGL_COMPONENT_TYPES[accessorDef.componentType];attributeTypeMap[threeAttributeName]=componentType,attributeNormalizedMap[threeAttributeName]=!0===accessorDef.normalized}}return parser.getDependency("bufferView",bufferViewIndex).then((function(bufferView){return new Promise((function(resolve){dracoLoader.decodeDracoFile(bufferView,(function(geometry){for(const attributeName in geometry.attributes){const attribute=geometry.attributes[attributeName],normalized=attributeNormalizedMap[attributeName];void 0!==normalized&&(attribute.normalized=normalized)}resolve(geometry)}),threeAttributeMap,attributeTypeMap)}))}))}}class GLTFTextureTransformExtension{constructor(){this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(texture,transform){return void 0!==transform.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===transform.offset&&void 0===transform.rotation&&void 0===transform.scale||(texture=texture.clone(),void 0!==transform.offset&&texture.offset.fromArray(transform.offset),void 0!==transform.rotation&&(texture.rotation=transform.rotation),void 0!==transform.scale&&texture.repeat.fromArray(transform.scale),texture.needsUpdate=!0),texture}}class GLTFLoader_GLTFMeshStandardSGMaterial extends three_module.Sb{constructor(params){super(),this.isGLTFSpecularGlossinessMaterial=!0;const specularMapParsFragmentChunk=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),glossinessMapParsFragmentChunk=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),specularMapFragmentChunk=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),glossinessMapFragmentChunk=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),lightPhysicalFragmentChunk=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),uniforms={specular:{value:(new three_module.w).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=uniforms,this.onBeforeCompile=function(shader){for(const uniformName in uniforms)shader.uniforms[uniformName]=uniforms[uniformName];shader.fragmentShader=shader.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>",glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>",specularMapFragmentChunk).replace("#include <metalnessmap_fragment>",glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>",lightPhysicalFragmentChunk)},Object.defineProperties(this,{specular:{get:function(){return uniforms.specular.value},set:function(v){uniforms.specular.value=v}},specularMap:{get:function(){return uniforms.specularMap.value},set:function(v){uniforms.specularMap.value=v,v?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return uniforms.glossiness.value},set:function(v){uniforms.glossiness.value=v}},glossinessMap:{get:function(){return uniforms.glossinessMap.value},set:function(v){uniforms.glossinessMap.value=v,v?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(params)}copy(source){return super.copy(source),this.specularMap=source.specularMap,this.specular.copy(source.specular),this.glossinessMap=source.glossinessMap,this.glossiness=source.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class GLTFLoader_GLTFMaterialsPbrSpecularGlossinessExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return GLTFLoader_GLTFMeshStandardSGMaterial}extendParams(materialParams,materialDef,parser){const pbrSpecularGlossiness=materialDef.extensions[this.name];materialParams.color=new three_module.w(1,1,1),materialParams.opacity=1;const pending=[];if(Array.isArray(pbrSpecularGlossiness.diffuseFactor)){const array=pbrSpecularGlossiness.diffuseFactor;materialParams.color.fromArray(array),materialParams.opacity=array[3]}if(void 0!==pbrSpecularGlossiness.diffuseTexture&&pending.push(parser.assignTexture(materialParams,"map",pbrSpecularGlossiness.diffuseTexture,three_module.Cd)),materialParams.emissive=new three_module.w(0,0,0),materialParams.glossiness=void 0!==pbrSpecularGlossiness.glossinessFactor?pbrSpecularGlossiness.glossinessFactor:1,materialParams.specular=new three_module.w(1,1,1),Array.isArray(pbrSpecularGlossiness.specularFactor)&&materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor),void 0!==pbrSpecularGlossiness.specularGlossinessTexture){const specGlossMapDef=pbrSpecularGlossiness.specularGlossinessTexture;pending.push(parser.assignTexture(materialParams,"glossinessMap",specGlossMapDef)),pending.push(parser.assignTexture(materialParams,"specularMap",specGlossMapDef,three_module.Cd))}return Promise.all(pending)}createMaterial(materialParams){const material=new GLTFLoader_GLTFMeshStandardSGMaterial(materialParams);return material.fog=!0,material.color=materialParams.color,material.map=void 0===materialParams.map?null:materialParams.map,material.lightMap=null,material.lightMapIntensity=1,material.aoMap=void 0===materialParams.aoMap?null:materialParams.aoMap,material.aoMapIntensity=1,material.emissive=materialParams.emissive,material.emissiveIntensity=void 0===materialParams.emissiveIntensity?1:materialParams.emissiveIntensity,material.emissiveMap=void 0===materialParams.emissiveMap?null:materialParams.emissiveMap,material.bumpMap=void 0===materialParams.bumpMap?null:materialParams.bumpMap,material.bumpScale=1,material.normalMap=void 0===materialParams.normalMap?null:materialParams.normalMap,material.normalMapType=three_module.bd,materialParams.normalScale&&(material.normalScale=materialParams.normalScale),material.displacementMap=null,material.displacementScale=1,material.displacementBias=0,material.specularMap=void 0===materialParams.specularMap?null:materialParams.specularMap,material.specular=materialParams.specular,material.glossinessMap=void 0===materialParams.glossinessMap?null:materialParams.glossinessMap,material.glossiness=materialParams.glossiness,material.alphaMap=null,material.envMap=void 0===materialParams.envMap?null:materialParams.envMap,material.envMapIntensity=1,material}}class GLTFMeshQuantizationExtension{constructor(){this.name=EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFLoader_GLTFCubicSplineInterpolant extends three_module.lb{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}copySampleValue_(index){const result=this.resultBuffer,values=this.sampleValues,valueSize=this.valueSize,offset=index*valueSize*3+valueSize;for(let i=0;i!==valueSize;i++)result[i]=values[offset+i];return result}}GLTFLoader_GLTFCubicSplineInterpolant.prototype.beforeStart_=GLTFLoader_GLTFCubicSplineInterpolant.prototype.copySampleValue_,GLTFLoader_GLTFCubicSplineInterpolant.prototype.afterEnd_=GLTFLoader_GLTFCubicSplineInterpolant.prototype.copySampleValue_,GLTFLoader_GLTFCubicSplineInterpolant.prototype.interpolate_=function(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,stride2=2*stride,stride3=3*stride,td=t1-t0,p=(t-t0)/td,pp=p*p,ppp=pp*p,offset1=i1*stride3,offset0=offset1-stride3,s2=-2*ppp+3*pp,s3=ppp-pp,s0=1-s2,s1=s3-pp+p;for(let i=0;i!==stride;i++){const p0=values[offset0+i+stride],m0=values[offset0+i+stride2]*td,p1=values[offset1+i+stride],m1=values[offset1+i]*td;result[i]=s0*p0+s1*m0+s2*p1+s3*m1}return result};const _q=new three_module.uc;class GLTFCubicSplineQuaternionInterpolant extends GLTFLoader_GLTFCubicSplineInterpolant{interpolate_(i1,t0,t,t1){const result=super.interpolate_(i1,t0,t,t1);return _q.fromArray(result).normalize().toArray(result),result}}const WEBGL_CONSTANTS_POINTS=0,WEBGL_CONSTANTS_LINES=1,WEBGL_CONSTANTS_LINE_LOOP=2,WEBGL_CONSTANTS_LINE_STRIP=3,WEBGL_CONSTANTS_TRIANGLES=4,WEBGL_CONSTANTS_TRIANGLE_STRIP=5,WEBGL_CONSTANTS_TRIANGLE_FAN=6,WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:three_module.Vb,9729:three_module.wb,9984:three_module.Xb,9985:three_module.yb,9986:three_module.Wb,9987:three_module.xb},WEBGL_WRAPPINGS={33071:three_module.u,33648:three_module.Ub,10497:three_module.Hc},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:three_module.nb,STEP:three_module.mb},ALPHA_MODES_OPAQUE="OPAQUE",ALPHA_MODES_MASK="MASK",ALPHA_MODES_BLEND="BLEND";function addUnknownExtensionsToUserData(knownExtensions,object,objectDef){for(const name in objectDef.extensions)void 0===knownExtensions[name]&&(object.userData.gltfExtensions=object.userData.gltfExtensions||{},object.userData.gltfExtensions[name]=objectDef.extensions[name])}function assignExtrasToUserData(object,gltfDef){void 0!==gltfDef.extras&&("object"==typeof gltfDef.extras?Object.assign(object.userData,gltfDef.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+gltfDef.extras))}function updateMorphTargets(mesh,meshDef){if(mesh.updateMorphTargets(),void 0!==meshDef.weights)for(let i=0,il=meshDef.weights.length;i<il;i++)mesh.morphTargetInfluences[i]=meshDef.weights[i];if(meshDef.extras&&Array.isArray(meshDef.extras.targetNames)){const targetNames=meshDef.extras.targetNames;if(mesh.morphTargetInfluences.length===targetNames.length){mesh.morphTargetDictionary={};for(let i=0,il=targetNames.length;i<il;i++)mesh.morphTargetDictionary[targetNames[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey(primitiveDef){const dracoExtension=primitiveDef.extensions&&primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];let geometryKey;return geometryKey=dracoExtension?"draco:"+dracoExtension.bufferView+":"+dracoExtension.indices+":"+createAttributesKey(dracoExtension.attributes):primitiveDef.indices+":"+createAttributesKey(primitiveDef.attributes)+":"+primitiveDef.mode,geometryKey}function createAttributesKey(attributes){let attributesKey="";const keys=Object.keys(attributes).sort();for(let i=0,il=keys.length;i<il;i++)attributesKey+=keys[i]+":"+attributes[keys[i]]+";";return attributesKey}function getNormalizedComponentScale(constructor){switch(constructor){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class GLTFLoader_GLTFParser{constructor(json={},options={}){this.json=json,this.extensions={},this.plugins={},this.options=options,this.cache=new GLTFRegistry,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const isSafari=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),isFirefox=navigator.userAgent.indexOf("Firefox")>-1,firefoxVersion=isFirefox?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;"undefined"==typeof createImageBitmap||isSafari||isFirefox&&firefoxVersion<98?this.textureLoader=new three_module.ed(this.options.manager):this.textureLoader=new three_module.hb(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new three_module.U(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(extensions){this.extensions=extensions}setPlugins(plugins){this.plugins=plugins}parse(onLoad,onError){const parser=this,json=this.json,extensions=this.extensions;this.cache.removeAll(),this._invokeAll((function(ext){return ext._markDefs&&ext._markDefs()})),Promise.all(this._invokeAll((function(ext){return ext.beforeRoot&&ext.beforeRoot()}))).then((function(){return Promise.all([parser.getDependencies("scene"),parser.getDependencies("animation"),parser.getDependencies("camera")])})).then((function(dependencies){const result={scene:dependencies[0][json.scene||0],scenes:dependencies[0],animations:dependencies[1],cameras:dependencies[2],asset:json.asset,parser:parser,userData:{}};addUnknownExtensionsToUserData(extensions,result,json),assignExtrasToUserData(result,json),Promise.all(parser._invokeAll((function(ext){return ext.afterRoot&&ext.afterRoot(result)}))).then((function(){onLoad(result)}))})).catch(onError)}_markDefs(){const nodeDefs=this.json.nodes||[],skinDefs=this.json.skins||[],meshDefs=this.json.meshes||[];for(let skinIndex=0,skinLength=skinDefs.length;skinIndex<skinLength;skinIndex++){const joints=skinDefs[skinIndex].joints;for(let i=0,il=joints.length;i<il;i++)nodeDefs[joints[i]].isBone=!0}for(let nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++){const nodeDef=nodeDefs[nodeIndex];void 0!==nodeDef.mesh&&(this._addNodeRef(this.meshCache,nodeDef.mesh),void 0!==nodeDef.skin&&(meshDefs[nodeDef.mesh].isSkinnedMesh=!0)),void 0!==nodeDef.camera&&this._addNodeRef(this.cameraCache,nodeDef.camera)}}_addNodeRef(cache,index){void 0!==index&&(void 0===cache.refs[index]&&(cache.refs[index]=cache.uses[index]=0),cache.refs[index]++)}_getNodeRef(cache,index,object){if(cache.refs[index]<=1)return object;const ref=object.clone(),updateMappings=(original,clone)=>{const mappings=this.associations.get(original);null!=mappings&&this.associations.set(clone,mappings);for(const[i,child]of original.children.entries())updateMappings(child,clone.children[i])};return updateMappings(object,ref),ref.name+="_instance_"+cache.uses[index]++,ref}_invokeOne(func){const extensions=Object.values(this.plugins);extensions.push(this);for(let i=0;i<extensions.length;i++){const result=func(extensions[i]);if(result)return result}return null}_invokeAll(func){const extensions=Object.values(this.plugins);extensions.unshift(this);const pending=[];for(let i=0;i<extensions.length;i++){const result=func(extensions[i]);result&&pending.push(result)}return pending}getDependency(type,index){const cacheKey=type+":"+index;let dependency=this.cache.get(cacheKey);if(!dependency){switch(type){case"scene":dependency=this.loadScene(index);break;case"node":dependency=this.loadNode(index);break;case"mesh":dependency=this._invokeOne((function(ext){return ext.loadMesh&&ext.loadMesh(index)}));break;case"accessor":dependency=this.loadAccessor(index);break;case"bufferView":dependency=this._invokeOne((function(ext){return ext.loadBufferView&&ext.loadBufferView(index)}));break;case"buffer":dependency=this.loadBuffer(index);break;case"material":dependency=this._invokeOne((function(ext){return ext.loadMaterial&&ext.loadMaterial(index)}));break;case"texture":dependency=this._invokeOne((function(ext){return ext.loadTexture&&ext.loadTexture(index)}));break;case"skin":dependency=this.loadSkin(index);break;case"animation":dependency=this._invokeOne((function(ext){return ext.loadAnimation&&ext.loadAnimation(index)}));break;case"camera":dependency=this.loadCamera(index);break;default:throw new Error("Unknown type: "+type)}this.cache.add(cacheKey,dependency)}return dependency}getDependencies(type){let dependencies=this.cache.get(type);if(!dependencies){const parser=this,defs=this.json[type+("mesh"===type?"es":"s")]||[];dependencies=Promise.all(defs.map((function(def,index){return parser.getDependency(type,index)}))),this.cache.add(type,dependencies)}return dependencies}loadBuffer(bufferIndex){const bufferDef=this.json.buffers[bufferIndex],loader=this.fileLoader;if(bufferDef.type&&"arraybuffer"!==bufferDef.type)throw new Error("THREE.GLTFLoader: "+bufferDef.type+" buffer type is not supported.");if(void 0===bufferDef.uri&&0===bufferIndex)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);const options=this.options;return new Promise((function(resolve,reject){loader.load(three_module.Bb.resolveURL(bufferDef.uri,options.path),resolve,void 0,(function(){reject(new Error('THREE.GLTFLoader: Failed to load buffer "'+bufferDef.uri+'".'))}))}))}loadBufferView(bufferViewIndex){const bufferViewDef=this.json.bufferViews[bufferViewIndex];return this.getDependency("buffer",bufferViewDef.buffer).then((function(buffer){const byteLength=bufferViewDef.byteLength||0,byteOffset=bufferViewDef.byteOffset||0;return buffer.slice(byteOffset,byteOffset+byteLength)}))}loadAccessor(accessorIndex){const parser=this,json=this.json,accessorDef=this.json.accessors[accessorIndex];if(void 0===accessorDef.bufferView&&void 0===accessorDef.sparse)return Promise.resolve(null);const pendingBufferViews=[];return void 0!==accessorDef.bufferView?pendingBufferViews.push(this.getDependency("bufferView",accessorDef.bufferView)):pendingBufferViews.push(null),void 0!==accessorDef.sparse&&(pendingBufferViews.push(this.getDependency("bufferView",accessorDef.sparse.indices.bufferView)),pendingBufferViews.push(this.getDependency("bufferView",accessorDef.sparse.values.bufferView))),Promise.all(pendingBufferViews).then((function(bufferViews){const bufferView=bufferViews[0],itemSize=WEBGL_TYPE_SIZES[accessorDef.type],TypedArray=WEBGL_COMPONENT_TYPES[accessorDef.componentType],elementBytes=TypedArray.BYTES_PER_ELEMENT,itemBytes=elementBytes*itemSize,byteOffset=accessorDef.byteOffset||0,byteStride=void 0!==accessorDef.bufferView?json.bufferViews[accessorDef.bufferView].byteStride:void 0,normalized=!0===accessorDef.normalized;let array,bufferAttribute;if(byteStride&&byteStride!==itemBytes){const ibSlice=Math.floor(byteOffset/byteStride),ibCacheKey="InterleavedBuffer:"+accessorDef.bufferView+":"+accessorDef.componentType+":"+ibSlice+":"+accessorDef.count;let ib=parser.cache.get(ibCacheKey);ib||(array=new TypedArray(bufferView,ibSlice*byteStride,accessorDef.count*byteStride/elementBytes),ib=new three_module.jb(array,byteStride/elementBytes),parser.cache.add(ibCacheKey,ib)),bufferAttribute=new three_module.kb(ib,itemSize,byteOffset%byteStride/elementBytes,normalized)}else array=null===bufferView?new TypedArray(accessorDef.count*itemSize):new TypedArray(bufferView,byteOffset,accessorDef.count*itemSize),bufferAttribute=new three_module.o(array,itemSize,normalized);if(void 0!==accessorDef.sparse){const itemSizeIndices=WEBGL_TYPE_SIZES.SCALAR,TypedArrayIndices=WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType],byteOffsetIndices=accessorDef.sparse.indices.byteOffset||0,byteOffsetValues=accessorDef.sparse.values.byteOffset||0,sparseIndices=new TypedArrayIndices(bufferViews[1],byteOffsetIndices,accessorDef.sparse.count*itemSizeIndices),sparseValues=new TypedArray(bufferViews[2],byteOffsetValues,accessorDef.sparse.count*itemSize);null!==bufferView&&(bufferAttribute=new three_module.o(bufferAttribute.array.slice(),bufferAttribute.itemSize,bufferAttribute.normalized));for(let i=0,il=sparseIndices.length;i<il;i++){const index=sparseIndices[i];if(bufferAttribute.setX(index,sparseValues[i*itemSize]),itemSize>=2&&bufferAttribute.setY(index,sparseValues[i*itemSize+1]),itemSize>=3&&bufferAttribute.setZ(index,sparseValues[i*itemSize+2]),itemSize>=4&&bufferAttribute.setW(index,sparseValues[i*itemSize+3]),itemSize>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return bufferAttribute}))}loadTexture(textureIndex){const json=this.json,options=this.options,sourceIndex=json.textures[textureIndex].source,sourceDef=json.images[sourceIndex];let loader=this.textureLoader;if(sourceDef.uri){const handler=options.manager.getHandler(sourceDef.uri);null!==handler&&(loader=handler)}return this.loadTextureImage(textureIndex,sourceIndex,loader)}loadTextureImage(textureIndex,sourceIndex,loader){const parser=this,json=this.json,textureDef=json.textures[textureIndex],sourceDef=json.images[sourceIndex],cacheKey=(sourceDef.uri||sourceDef.bufferView)+":"+textureDef.sampler;if(this.textureCache[cacheKey])return this.textureCache[cacheKey];const promise=this.loadImageSource(sourceIndex,loader).then((function(texture){texture.flipY=!1,textureDef.name&&(texture.name=textureDef.name);const sampler=(json.samplers||{})[textureDef.sampler]||{};return texture.magFilter=WEBGL_FILTERS[sampler.magFilter]||three_module.wb,texture.minFilter=WEBGL_FILTERS[sampler.minFilter]||three_module.xb,texture.wrapS=WEBGL_WRAPPINGS[sampler.wrapS]||three_module.Hc,texture.wrapT=WEBGL_WRAPPINGS[sampler.wrapT]||three_module.Hc,parser.associations.set(texture,{textures:textureIndex}),texture})).catch((function(){return null}));return this.textureCache[cacheKey]=promise,promise}loadImageSource(sourceIndex,loader){const parser=this,json=this.json,options=this.options;if(void 0!==this.sourceCache[sourceIndex])return this.sourceCache[sourceIndex].then((texture=>texture.clone()));const sourceDef=json.images[sourceIndex],URL=self.URL||self.webkitURL;let sourceURI=sourceDef.uri||"",isObjectURL=!1;if(void 0!==sourceDef.bufferView)sourceURI=parser.getDependency("bufferView",sourceDef.bufferView).then((function(bufferView){isObjectURL=!0;const blob=new Blob([bufferView],{type:sourceDef.mimeType});return sourceURI=URL.createObjectURL(blob),sourceURI}));else if(void 0===sourceDef.uri)throw new Error("THREE.GLTFLoader: Image "+sourceIndex+" is missing URI and bufferView");const promise=Promise.resolve(sourceURI).then((function(sourceURI){return new Promise((function(resolve,reject){let onLoad=resolve;!0===loader.isImageBitmapLoader&&(onLoad=function(imageBitmap){const texture=new three_module.dd(imageBitmap);texture.needsUpdate=!0,resolve(texture)}),loader.load(three_module.Bb.resolveURL(sourceURI,options.path),onLoad,void 0,reject)}))})).then((function(texture){return!0===isObjectURL&&URL.revokeObjectURL(sourceURI),texture.userData.mimeType=sourceDef.mimeType||function getImageURIMimeType(uri){return uri.search(/\.jpe?g($|\?)/i)>0||0===uri.search(/^data\:image\/jpeg/)?"image/jpeg":uri.search(/\.webp($|\?)/i)>0||0===uri.search(/^data\:image\/webp/)?"image/webp":"image/png"}(sourceDef.uri),texture})).catch((function(error){throw console.error("THREE.GLTFLoader: Couldn't load texture",sourceURI),error}));return this.sourceCache[sourceIndex]=promise,promise}assignTexture(materialParams,mapName,mapDef,encoding){const parser=this;return this.getDependency("texture",mapDef.index).then((function(texture){if(void 0===mapDef.texCoord||0==mapDef.texCoord||"aoMap"===mapName&&1==mapDef.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+mapDef.texCoord+" for texture "+mapName+" not yet supported."),parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const transform=void 0!==mapDef.extensions?mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(transform){const gltfReference=parser.associations.get(texture);texture=parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture,transform),parser.associations.set(texture,gltfReference)}}return void 0!==encoding&&(texture.encoding=encoding),materialParams[mapName]=texture,texture}))}assignFinalMaterial(mesh){const geometry=mesh.geometry;let material=mesh.material;const useDerivativeTangents=void 0===geometry.attributes.tangent,useVertexColors=void 0!==geometry.attributes.color,useFlatShading=void 0===geometry.attributes.normal;if(mesh.isPoints){const cacheKey="PointsMaterial:"+material.uuid;let pointsMaterial=this.cache.get(cacheKey);pointsMaterial||(pointsMaterial=new three_module.sc,three_module.Hb.prototype.copy.call(pointsMaterial,material),pointsMaterial.color.copy(material.color),pointsMaterial.map=material.map,pointsMaterial.sizeAttenuation=!1,this.cache.add(cacheKey,pointsMaterial)),material=pointsMaterial}else if(mesh.isLine){const cacheKey="LineBasicMaterial:"+material.uuid;let lineMaterial=this.cache.get(cacheKey);lineMaterial||(lineMaterial=new three_module.sb,three_module.Hb.prototype.copy.call(lineMaterial,material),lineMaterial.color.copy(material.color),this.cache.add(cacheKey,lineMaterial)),material=lineMaterial}if(useDerivativeTangents||useVertexColors||useFlatShading){let cacheKey="ClonedMaterial:"+material.uuid+":";material.isGLTFSpecularGlossinessMaterial&&(cacheKey+="specular-glossiness:"),useDerivativeTangents&&(cacheKey+="derivative-tangents:"),useVertexColors&&(cacheKey+="vertex-colors:"),useFlatShading&&(cacheKey+="flat-shading:");let cachedMaterial=this.cache.get(cacheKey);cachedMaterial||(cachedMaterial=material.clone(),useVertexColors&&(cachedMaterial.vertexColors=!0),useFlatShading&&(cachedMaterial.flatShading=!0),useDerivativeTangents&&(cachedMaterial.normalScale&&(cachedMaterial.normalScale.y*=-1),cachedMaterial.clearcoatNormalScale&&(cachedMaterial.clearcoatNormalScale.y*=-1)),this.cache.add(cacheKey,cachedMaterial),this.associations.set(cachedMaterial,this.associations.get(material))),material=cachedMaterial}material.aoMap&&void 0===geometry.attributes.uv2&&void 0!==geometry.attributes.uv&&geometry.setAttribute("uv2",geometry.attributes.uv),mesh.material=material}getMaterialType(){return three_module.Sb}loadMaterial(materialIndex){const parser=this,json=this.json,extensions=this.extensions,materialDef=json.materials[materialIndex];let materialType;const materialParams={},materialExtensions=materialDef.extensions||{},pending=[];if(materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const sgExtension=extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];materialType=sgExtension.getMaterialType(),pending.push(sgExtension.extendParams(materialParams,materialDef,parser))}else if(materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]){const kmuExtension=extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];materialType=kmuExtension.getMaterialType(),pending.push(kmuExtension.extendParams(materialParams,materialDef,parser))}else{const metallicRoughness=materialDef.pbrMetallicRoughness||{};if(materialParams.color=new three_module.w(1,1,1),materialParams.opacity=1,Array.isArray(metallicRoughness.baseColorFactor)){const array=metallicRoughness.baseColorFactor;materialParams.color.fromArray(array),materialParams.opacity=array[3]}void 0!==metallicRoughness.baseColorTexture&&pending.push(parser.assignTexture(materialParams,"map",metallicRoughness.baseColorTexture,three_module.Cd)),materialParams.metalness=void 0!==metallicRoughness.metallicFactor?metallicRoughness.metallicFactor:1,materialParams.roughness=void 0!==metallicRoughness.roughnessFactor?metallicRoughness.roughnessFactor:1,void 0!==metallicRoughness.metallicRoughnessTexture&&(pending.push(parser.assignTexture(materialParams,"metalnessMap",metallicRoughness.metallicRoughnessTexture)),pending.push(parser.assignTexture(materialParams,"roughnessMap",metallicRoughness.metallicRoughnessTexture))),materialType=this._invokeOne((function(ext){return ext.getMaterialType&&ext.getMaterialType(materialIndex)})),pending.push(Promise.all(this._invokeAll((function(ext){return ext.extendMaterialParams&&ext.extendMaterialParams(materialIndex,materialParams)}))))}!0===materialDef.doubleSided&&(materialParams.side=three_module.M);const alphaMode=materialDef.alphaMode||ALPHA_MODES_OPAQUE;if(alphaMode===ALPHA_MODES_BLEND?(materialParams.transparent=!0,materialParams.depthWrite=!1):(materialParams.transparent=!1,alphaMode===ALPHA_MODES_MASK&&(materialParams.alphaTest=void 0!==materialDef.alphaCutoff?materialDef.alphaCutoff:.5)),void 0!==materialDef.normalTexture&&materialType!==three_module.Mb&&(pending.push(parser.assignTexture(materialParams,"normalMap",materialDef.normalTexture)),materialParams.normalScale=new three_module.td(1,1),void 0!==materialDef.normalTexture.scale)){const scale=materialDef.normalTexture.scale;materialParams.normalScale.set(scale,scale)}return void 0!==materialDef.occlusionTexture&&materialType!==three_module.Mb&&(pending.push(parser.assignTexture(materialParams,"aoMap",materialDef.occlusionTexture)),void 0!==materialDef.occlusionTexture.strength&&(materialParams.aoMapIntensity=materialDef.occlusionTexture.strength)),void 0!==materialDef.emissiveFactor&&materialType!==three_module.Mb&&(materialParams.emissive=(new three_module.w).fromArray(materialDef.emissiveFactor)),void 0!==materialDef.emissiveTexture&&materialType!==three_module.Mb&&pending.push(parser.assignTexture(materialParams,"emissiveMap",materialDef.emissiveTexture,three_module.Cd)),Promise.all(pending).then((function(){let material;return material=materialType===GLTFLoader_GLTFMeshStandardSGMaterial?extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams):new materialType(materialParams),materialDef.name&&(material.name=materialDef.name),assignExtrasToUserData(material,materialDef),parser.associations.set(material,{materials:materialIndex}),materialDef.extensions&&addUnknownExtensionsToUserData(extensions,material,materialDef),material}))}createUniqueName(originalName){const sanitizedName=three_module.tc.sanitizeNodeName(originalName||"");let name=sanitizedName;for(let i=1;this.nodeNamesUsed[name];++i)name=sanitizedName+"_"+i;return this.nodeNamesUsed[name]=!0,name}loadGeometries(primitives){const parser=this,extensions=this.extensions,cache=this.primitiveCache;function createDracoPrimitive(primitive){return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive,parser).then((function(geometry){return addPrimitiveAttributes(geometry,primitive,parser)}))}const pending=[];for(let i=0,il=primitives.length;i<il;i++){const primitive=primitives[i],cacheKey=createPrimitiveKey(primitive),cached=cache[cacheKey];if(cached)pending.push(cached.promise);else{let geometryPromise;geometryPromise=primitive.extensions&&primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?createDracoPrimitive(primitive):addPrimitiveAttributes(new three_module.p,primitive,parser),cache[cacheKey]={primitive:primitive,promise:geometryPromise},pending.push(geometryPromise)}}return Promise.all(pending)}loadMesh(meshIndex){const parser=this,json=this.json,extensions=this.extensions,meshDef=json.meshes[meshIndex],primitives=meshDef.primitives,pending=[];for(let i=0,il=primitives.length;i<il;i++){const material=void 0===primitives[i].material?(void 0===(cache=this.cache).DefaultMaterial&&(cache.DefaultMaterial=new three_module.Sb({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:three_module.Y})),cache.DefaultMaterial):this.getDependency("material",primitives[i].material);pending.push(material)}var cache;return pending.push(parser.loadGeometries(primitives)),Promise.all(pending).then((function(results){const materials=results.slice(0,results.length-1),geometries=results[results.length-1],meshes=[];for(let i=0,il=geometries.length;i<il;i++){const geometry=geometries[i],primitive=primitives[i];let mesh;const material=materials[i];if(primitive.mode===WEBGL_CONSTANTS_TRIANGLES||primitive.mode===WEBGL_CONSTANTS_TRIANGLE_STRIP||primitive.mode===WEBGL_CONSTANTS_TRIANGLE_FAN||void 0===primitive.mode)mesh=!0===meshDef.isSkinnedMesh?new three_module.Qc(geometry,material):new three_module.Lb(geometry,material),!0!==mesh.isSkinnedMesh||mesh.geometry.attributes.skinWeight.normalized||mesh.normalizeSkinWeights(),primitive.mode===WEBGL_CONSTANTS_TRIANGLE_STRIP?mesh.geometry=toTrianglesDrawMode(mesh.geometry,three_module.jd):primitive.mode===WEBGL_CONSTANTS_TRIANGLE_FAN&&(mesh.geometry=toTrianglesDrawMode(mesh.geometry,three_module.id));else if(primitive.mode===WEBGL_CONSTANTS_LINES)mesh=new three_module.ub(geometry,material);else if(primitive.mode===WEBGL_CONSTANTS_LINE_STRIP)mesh=new three_module.qb(geometry,material);else if(primitive.mode===WEBGL_CONSTANTS_LINE_LOOP)mesh=new three_module.tb(geometry,material);else{if(primitive.mode!==WEBGL_CONSTANTS_POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+primitive.mode);mesh=new three_module.rc(geometry,material)}Object.keys(mesh.geometry.morphAttributes).length>0&&updateMorphTargets(mesh,meshDef),mesh.name=parser.createUniqueName(meshDef.name||"mesh_"+meshIndex),assignExtrasToUserData(mesh,meshDef),primitive.extensions&&addUnknownExtensionsToUserData(extensions,mesh,primitive),parser.assignFinalMaterial(mesh),meshes.push(mesh)}for(let i=0,il=meshes.length;i<il;i++)parser.associations.set(meshes[i],{meshes:meshIndex,primitives:i});if(1===meshes.length)return meshes[0];const group=new three_module.db;parser.associations.set(group,{meshes:meshIndex});for(let i=0,il=meshes.length;i<il;i++)group.add(meshes[i]);return group}))}loadCamera(cameraIndex){let camera;const cameraDef=this.json.cameras[cameraIndex],params=cameraDef[cameraDef.type];if(params)return"perspective"===cameraDef.type?camera=new three_module.lc(three_module.Ib.radToDeg(params.yfov),params.aspectRatio||1,params.znear||1,params.zfar||2e6):"orthographic"===cameraDef.type&&(camera=new three_module.jc(-params.xmag,params.xmag,params.ymag,-params.ymag,params.znear,params.zfar)),cameraDef.name&&(camera.name=this.createUniqueName(cameraDef.name)),assignExtrasToUserData(camera,cameraDef),Promise.resolve(camera);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(skinIndex){const skinDef=this.json.skins[skinIndex],skinEntry={joints:skinDef.joints};return void 0===skinDef.inverseBindMatrices?Promise.resolve(skinEntry):this.getDependency("accessor",skinDef.inverseBindMatrices).then((function(accessor){return skinEntry.inverseBindMatrices=accessor,skinEntry}))}loadAnimation(animationIndex){const animationDef=this.json.animations[animationIndex],pendingNodes=[],pendingInputAccessors=[],pendingOutputAccessors=[],pendingSamplers=[],pendingTargets=[];for(let i=0,il=animationDef.channels.length;i<il;i++){const channel=animationDef.channels[i],sampler=animationDef.samplers[channel.sampler],target=channel.target,name=void 0!==target.node?target.node:target.id,input=void 0!==animationDef.parameters?animationDef.parameters[sampler.input]:sampler.input,output=void 0!==animationDef.parameters?animationDef.parameters[sampler.output]:sampler.output;pendingNodes.push(this.getDependency("node",name)),pendingInputAccessors.push(this.getDependency("accessor",input)),pendingOutputAccessors.push(this.getDependency("accessor",output)),pendingSamplers.push(sampler),pendingTargets.push(target)}return Promise.all([Promise.all(pendingNodes),Promise.all(pendingInputAccessors),Promise.all(pendingOutputAccessors),Promise.all(pendingSamplers),Promise.all(pendingTargets)]).then((function(dependencies){const nodes=dependencies[0],inputAccessors=dependencies[1],outputAccessors=dependencies[2],samplers=dependencies[3],targets=dependencies[4],tracks=[];for(let i=0,il=nodes.length;i<il;i++){const node=nodes[i],inputAccessor=inputAccessors[i],outputAccessor=outputAccessors[i],sampler=samplers[i],target=targets[i];if(void 0===node)continue;let TypedKeyframeTrack;switch(node.updateMatrix(),node.matrixAutoUpdate=!0,PATH_PROPERTIES[target.path]){case PATH_PROPERTIES.weights:TypedKeyframeTrack=three_module.dc;break;case PATH_PROPERTIES.rotation:TypedKeyframeTrack=three_module.vc;break;default:TypedKeyframeTrack=three_module.wd}const targetName=node.name?node.name:node.uuid,interpolation=void 0!==sampler.interpolation?INTERPOLATION[sampler.interpolation]:three_module.nb,targetNames=[];PATH_PROPERTIES[target.path]===PATH_PROPERTIES.weights?node.traverse((function(object){object.morphTargetInfluences&&targetNames.push(object.name?object.name:object.uuid)})):targetNames.push(targetName);let outputArray=outputAccessor.array;if(outputAccessor.normalized){const scale=getNormalizedComponentScale(outputArray.constructor),scaled=new Float32Array(outputArray.length);for(let j=0,jl=outputArray.length;j<jl;j++)scaled[j]=outputArray[j]*scale;outputArray=scaled}for(let j=0,jl=targetNames.length;j<jl;j++){const track=new TypedKeyframeTrack(targetNames[j]+"."+PATH_PROPERTIES[target.path],inputAccessor.array,outputArray,interpolation);"CUBICSPLINE"===sampler.interpolation&&(track.createInterpolant=function InterpolantFactoryMethodGLTFCubicSpline(result){return new(this instanceof three_module.vc?GLTFCubicSplineQuaternionInterpolant:GLTFLoader_GLTFCubicSplineInterpolant)(this.times,this.values,this.getValueSize()/3,result)},track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),tracks.push(track)}}const name=animationDef.name?animationDef.name:"animation_"+animationIndex;return new three_module.e(name,void 0,tracks)}))}createNodeMesh(nodeIndex){const json=this.json,parser=this,nodeDef=json.nodes[nodeIndex];return void 0===nodeDef.mesh?null:parser.getDependency("mesh",nodeDef.mesh).then((function(mesh){const node=parser._getNodeRef(parser.meshCache,nodeDef.mesh,mesh);return void 0!==nodeDef.weights&&node.traverse((function(o){if(o.isMesh)for(let i=0,il=nodeDef.weights.length;i<il;i++)o.morphTargetInfluences[i]=nodeDef.weights[i]})),node}))}loadNode(nodeIndex){const json=this.json,extensions=this.extensions,parser=this,nodeDef=json.nodes[nodeIndex],nodeName=nodeDef.name?parser.createUniqueName(nodeDef.name):"";return function(){const pending=[],meshPromise=parser._invokeOne((function(ext){return ext.createNodeMesh&&ext.createNodeMesh(nodeIndex)}));return meshPromise&&pending.push(meshPromise),void 0!==nodeDef.camera&&pending.push(parser.getDependency("camera",nodeDef.camera).then((function(camera){return parser._getNodeRef(parser.cameraCache,nodeDef.camera,camera)}))),parser._invokeAll((function(ext){return ext.createNodeAttachment&&ext.createNodeAttachment(nodeIndex)})).forEach((function(promise){pending.push(promise)})),Promise.all(pending)}().then((function(objects){let node;if(node=!0===nodeDef.isBone?new three_module.i:objects.length>1?new three_module.db:1===objects.length?objects[0]:new three_module.ec,node!==objects[0])for(let i=0,il=objects.length;i<il;i++)node.add(objects[i]);if(nodeDef.name&&(node.userData.name=nodeDef.name,node.name=nodeName),assignExtrasToUserData(node,nodeDef),nodeDef.extensions&&addUnknownExtensionsToUserData(extensions,node,nodeDef),void 0!==nodeDef.matrix){const matrix=new three_module.Kb;matrix.fromArray(nodeDef.matrix),node.applyMatrix4(matrix)}else void 0!==nodeDef.translation&&node.position.fromArray(nodeDef.translation),void 0!==nodeDef.rotation&&node.quaternion.fromArray(nodeDef.rotation),void 0!==nodeDef.scale&&node.scale.fromArray(nodeDef.scale);return parser.associations.has(node)||parser.associations.set(node,{}),parser.associations.get(node).nodes=nodeIndex,node}))}loadScene(sceneIndex){const json=this.json,extensions=this.extensions,sceneDef=this.json.scenes[sceneIndex],parser=this,scene=new three_module.db;sceneDef.name&&(scene.name=parser.createUniqueName(sceneDef.name)),assignExtrasToUserData(scene,sceneDef),sceneDef.extensions&&addUnknownExtensionsToUserData(extensions,scene,sceneDef);const nodeIds=sceneDef.nodes||[],pending=[];for(let i=0,il=nodeIds.length;i<il;i++)pending.push(buildNodeHierarchy(nodeIds[i],scene,json,parser));return Promise.all(pending).then((function(){return parser.associations=(node=>{const reducedAssociations=new Map;for(const[key,value]of parser.associations)(key instanceof three_module.Hb||key instanceof three_module.dd)&&reducedAssociations.set(key,value);return node.traverse((node=>{const mappings=parser.associations.get(node);null!=mappings&&reducedAssociations.set(node,mappings)})),reducedAssociations})(scene),scene}))}}function buildNodeHierarchy(nodeId,parentObject,json,parser){const nodeDef=json.nodes[nodeId];return parser.getDependency("node",nodeId).then((function(node){if(void 0===nodeDef.skin)return node;let skinEntry;return parser.getDependency("skin",nodeDef.skin).then((function(skin){skinEntry=skin;const pendingJoints=[];for(let i=0,il=skinEntry.joints.length;i<il;i++)pendingJoints.push(parser.getDependency("node",skinEntry.joints[i]));return Promise.all(pendingJoints)})).then((function(jointNodes){return node.traverse((function(mesh){if(!mesh.isMesh)return;const bones=[],boneInverses=[];for(let j=0,jl=jointNodes.length;j<jl;j++){const jointNode=jointNodes[j];if(jointNode){bones.push(jointNode);const mat=new three_module.Kb;void 0!==skinEntry.inverseBindMatrices&&mat.fromArray(skinEntry.inverseBindMatrices.array,16*j),boneInverses.push(mat)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',skinEntry.joints[j])}mesh.bind(new three_module.Oc(bones,boneInverses),mesh.matrixWorld)})),node}))})).then((function(node){parentObject.add(node);const pending=[];if(nodeDef.children){const children=nodeDef.children;for(let i=0,il=children.length;i<il;i++){const child=children[i];pending.push(buildNodeHierarchy(child,node,json,parser))}}return Promise.all(pending)}))}function addPrimitiveAttributes(geometry,primitiveDef,parser){const attributes=primitiveDef.attributes,pending=[];function assignAttributeAccessor(accessorIndex,attributeName){return parser.getDependency("accessor",accessorIndex).then((function(accessor){geometry.setAttribute(attributeName,accessor)}))}for(const gltfAttributeName in attributes){const threeAttributeName=ATTRIBUTES[gltfAttributeName]||gltfAttributeName.toLowerCase();threeAttributeName in geometry.attributes||pending.push(assignAttributeAccessor(attributes[gltfAttributeName],threeAttributeName))}if(void 0!==primitiveDef.indices&&!geometry.index){const accessor=parser.getDependency("accessor",primitiveDef.indices).then((function(accessor){geometry.setIndex(accessor)}));pending.push(accessor)}return assignExtrasToUserData(geometry,primitiveDef),function computeBounds(geometry,primitiveDef,parser){const attributes=primitiveDef.attributes,box=new three_module.k;if(void 0===attributes.POSITION)return;{const accessor=parser.json.accessors[attributes.POSITION],min=accessor.min,max=accessor.max;if(void 0===min||void 0===max)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(box.set(new three_module.ud(min[0],min[1],min[2]),new three_module.ud(max[0],max[1],max[2])),accessor.normalized){const boxScale=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);box.min.multiplyScalar(boxScale),box.max.multiplyScalar(boxScale)}}const targets=primitiveDef.targets;if(void 0!==targets){const maxDisplacement=new three_module.ud,vector=new three_module.ud;for(let i=0,il=targets.length;i<il;i++){const target=targets[i];if(void 0!==target.POSITION){const accessor=parser.json.accessors[target.POSITION],min=accessor.min,max=accessor.max;if(void 0!==min&&void 0!==max){if(vector.setX(Math.max(Math.abs(min[0]),Math.abs(max[0]))),vector.setY(Math.max(Math.abs(min[1]),Math.abs(max[1]))),vector.setZ(Math.max(Math.abs(min[2]),Math.abs(max[2]))),accessor.normalized){const boxScale=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);vector.multiplyScalar(boxScale)}maxDisplacement.max(vector)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}box.expandByVector(maxDisplacement)}geometry.boundingBox=box;const sphere=new three_module.Rc;box.getCenter(sphere.center),sphere.radius=box.min.distanceTo(box.max)/2,geometry.boundingSphere=sphere}(geometry,primitiveDef,parser),Promise.all(pending).then((function(){return void 0!==primitiveDef.targets?function addMorphTargets(geometry,targets,parser){let hasMorphPosition=!1,hasMorphNormal=!1,hasMorphColor=!1;for(let i=0,il=targets.length;i<il;i++){const target=targets[i];if(void 0!==target.POSITION&&(hasMorphPosition=!0),void 0!==target.NORMAL&&(hasMorphNormal=!0),void 0!==target.COLOR_0&&(hasMorphColor=!0),hasMorphPosition&&hasMorphNormal&&hasMorphColor)break}if(!hasMorphPosition&&!hasMorphNormal&&!hasMorphColor)return Promise.resolve(geometry);const pendingPositionAccessors=[],pendingNormalAccessors=[],pendingColorAccessors=[];for(let i=0,il=targets.length;i<il;i++){const target=targets[i];if(hasMorphPosition){const pendingAccessor=void 0!==target.POSITION?parser.getDependency("accessor",target.POSITION):geometry.attributes.position;pendingPositionAccessors.push(pendingAccessor)}if(hasMorphNormal){const pendingAccessor=void 0!==target.NORMAL?parser.getDependency("accessor",target.NORMAL):geometry.attributes.normal;pendingNormalAccessors.push(pendingAccessor)}if(hasMorphColor){const pendingAccessor=void 0!==target.COLOR_0?parser.getDependency("accessor",target.COLOR_0):geometry.attributes.color;pendingColorAccessors.push(pendingAccessor)}}return Promise.all([Promise.all(pendingPositionAccessors),Promise.all(pendingNormalAccessors),Promise.all(pendingColorAccessors)]).then((function(accessors){const morphPositions=accessors[0],morphNormals=accessors[1],morphColors=accessors[2];return hasMorphPosition&&(geometry.morphAttributes.position=morphPositions),hasMorphNormal&&(geometry.morphAttributes.normal=morphNormals),hasMorphColor&&(geometry.morphAttributes.color=morphColors),geometry.morphTargetsRelative=!0,geometry}))}(geometry,primitiveDef.targets,parser):geometry}))}function toTrianglesDrawMode(geometry,drawMode){let index=geometry.getIndex();if(null===index){const indices=[],position=geometry.getAttribute("position");if(void 0===position)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),geometry;for(let i=0;i<position.count;i++)indices.push(i);geometry.setIndex(indices),index=geometry.getIndex()}const numberOfTriangles=index.count-2,newIndices=[];if(drawMode===three_module.id)for(let i=1;i<=numberOfTriangles;i++)newIndices.push(index.getX(0)),newIndices.push(index.getX(i)),newIndices.push(index.getX(i+1));else for(let i=0;i<numberOfTriangles;i++)i%2==0?(newIndices.push(index.getX(i)),newIndices.push(index.getX(i+1)),newIndices.push(index.getX(i+2))):(newIndices.push(index.getX(i+2)),newIndices.push(index.getX(i+1)),newIndices.push(index.getX(i)));newIndices.length/3!==numberOfTriangles&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const newGeometry=geometry.clone();return newGeometry.setIndex(newIndices),newGeometry}const _taskCache=new WeakMap;class DRACOLoader_DRACOLoader extends three_module.Ab{constructor(manager){super(manager),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(path){return this.decoderPath=path,this}setDecoderConfig(config){return this.decoderConfig=config,this}setWorkerLimit(workerLimit){return this.workerLimit=workerLimit,this}load(url,onLoad,onProgress,onError){const loader=new three_module.U(this.manager);loader.setPath(this.path),loader.setResponseType("arraybuffer"),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,(buffer=>{const taskConfig={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(buffer,taskConfig).then(onLoad).catch(onError)}),onProgress,onError)}decodeDracoFile(buffer,callback,attributeIDs,attributeTypes){const taskConfig={attributeIDs:attributeIDs||this.defaultAttributeIDs,attributeTypes:attributeTypes||this.defaultAttributeTypes,useUniqueIDs:!!attributeIDs};this.decodeGeometry(buffer,taskConfig).then(callback)}decodeGeometry(buffer,taskConfig){for(const attribute in taskConfig.attributeTypes){const type=taskConfig.attributeTypes[attribute];void 0!==type.BYTES_PER_ELEMENT&&(taskConfig.attributeTypes[attribute]=type.name)}const taskKey=JSON.stringify(taskConfig);if(_taskCache.has(buffer)){const cachedTask=_taskCache.get(buffer);if(cachedTask.key===taskKey)return cachedTask.promise;if(0===buffer.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let worker;const taskID=this.workerNextTaskID++,taskCost=buffer.byteLength,geometryPending=this._getWorker(taskID,taskCost).then((_worker=>(worker=_worker,new Promise(((resolve,reject)=>{worker._callbacks[taskID]={resolve:resolve,reject:reject},worker.postMessage({type:"decode",id:taskID,taskConfig:taskConfig,buffer:buffer},[buffer])}))))).then((message=>this._createGeometry(message.geometry)));return geometryPending.catch((()=>!0)).then((()=>{worker&&taskID&&this._releaseTask(worker,taskID)})),_taskCache.set(buffer,{key:taskKey,promise:geometryPending}),geometryPending}_createGeometry(geometryData){const geometry=new three_module.p;geometryData.index&&geometry.setIndex(new three_module.o(geometryData.index.array,1));for(let i=0;i<geometryData.attributes.length;i++){const attribute=geometryData.attributes[i],name=attribute.name,array=attribute.array,itemSize=attribute.itemSize;geometry.setAttribute(name,new three_module.o(array,itemSize))}return geometry}_loadLibrary(url,responseType){const loader=new three_module.U(this.manager);return loader.setPath(this.decoderPath),loader.setResponseType(responseType),loader.setWithCredentials(this.withCredentials),new Promise(((resolve,reject)=>{loader.load(url,resolve,void 0,reject)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const useJS="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,librariesPending=[];return useJS?librariesPending.push(this._loadLibrary("draco_decoder.js","text")):(librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js","text")),librariesPending.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(librariesPending).then((libraries=>{const jsContent=libraries[0];useJS||(this.decoderConfig.wasmBinary=libraries[1]);const fn=DRACOWorker.toString(),body=["/* draco decoder */",jsContent,"","/* worker */",fn.substring(fn.indexOf("{")+1,fn.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([body]))})),this.decoderPending}_getWorker(taskID,taskCost){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const worker=new Worker(this.workerSourceURL);worker._callbacks={},worker._taskCosts={},worker._taskLoad=0,worker.postMessage({type:"init",decoderConfig:this.decoderConfig}),worker.onmessage=function(e){const message=e.data;switch(message.type){case"decode":worker._callbacks[message.id].resolve(message);break;case"error":worker._callbacks[message.id].reject(message);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+message.type+'"')}},this.workerPool.push(worker)}else this.workerPool.sort((function(a,b){return a._taskLoad>b._taskLoad?-1:1}));const worker=this.workerPool[this.workerPool.length-1];return worker._taskCosts[taskID]=taskCost,worker._taskLoad+=taskCost,worker}))}_releaseTask(worker,taskID){worker._taskLoad-=worker._taskCosts[taskID],delete worker._callbacks[taskID],delete worker._taskCosts[taskID]}debug(){console.log("Task load: ",this.workerPool.map((worker=>worker._taskLoad)))}dispose(){for(let i=0;i<this.workerPool.length;++i)this.workerPool[i].terminate();return this.workerPool.length=0,this}}function DRACOWorker(){let decoderConfig,decoderPending;function decodeAttribute(draco,decoder,dracoGeometry,attributeName,attributeType,attribute){const numComponents=attribute.num_components(),numValues=dracoGeometry.num_points()*numComponents,byteLength=numValues*attributeType.BYTES_PER_ELEMENT,dataType=function getDracoDataType(draco,attributeType){switch(attributeType){case Float32Array:return draco.DT_FLOAT32;case Int8Array:return draco.DT_INT8;case Int16Array:return draco.DT_INT16;case Int32Array:return draco.DT_INT32;case Uint8Array:return draco.DT_UINT8;case Uint16Array:return draco.DT_UINT16;case Uint32Array:return draco.DT_UINT32}}(draco,attributeType),ptr=draco._malloc(byteLength);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,dataType,byteLength,ptr);const array=new attributeType(draco.HEAPF32.buffer,ptr,numValues).slice();return draco._free(ptr),{name:attributeName,array:array,itemSize:numComponents}}onmessage=function(e){const message=e.data;switch(message.type){case"init":decoderConfig=message.decoderConfig,decoderPending=new Promise((function(resolve){decoderConfig.onModuleLoaded=function(draco){resolve({draco:draco})},DracoDecoderModule(decoderConfig)}));break;case"decode":const buffer=message.buffer,taskConfig=message.taskConfig;decoderPending.then((module=>{const draco=module.draco,decoder=new draco.Decoder,decoderBuffer=new draco.DecoderBuffer;decoderBuffer.Init(new Int8Array(buffer),buffer.byteLength);try{const geometry=function decodeGeometry(draco,decoder,decoderBuffer,taskConfig){const attributeIDs=taskConfig.attributeIDs,attributeTypes=taskConfig.attributeTypes;let dracoGeometry,decodingStatus;const geometryType=decoder.GetEncodedGeometryType(decoderBuffer);if(geometryType===draco.TRIANGULAR_MESH)dracoGeometry=new draco.Mesh,decodingStatus=decoder.DecodeBufferToMesh(decoderBuffer,dracoGeometry);else{if(geometryType!==draco.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");dracoGeometry=new draco.PointCloud,decodingStatus=decoder.DecodeBufferToPointCloud(decoderBuffer,dracoGeometry)}if(!decodingStatus.ok()||0===dracoGeometry.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+decodingStatus.error_msg());const geometry={index:null,attributes:[]};for(const attributeName in attributeIDs){const attributeType=self[attributeTypes[attributeName]];let attribute,attributeID;if(taskConfig.useUniqueIDs)attributeID=attributeIDs[attributeName],attribute=decoder.GetAttributeByUniqueId(dracoGeometry,attributeID);else{if(attributeID=decoder.GetAttributeId(dracoGeometry,draco[attributeIDs[attributeName]]),-1===attributeID)continue;attribute=decoder.GetAttribute(dracoGeometry,attributeID)}geometry.attributes.push(decodeAttribute(draco,decoder,dracoGeometry,attributeName,attributeType,attribute))}geometryType===draco.TRIANGULAR_MESH&&(geometry.index=function decodeIndex(draco,decoder,dracoGeometry){const numIndices=3*dracoGeometry.num_faces(),byteLength=4*numIndices,ptr=draco._malloc(byteLength);decoder.GetTrianglesUInt32Array(dracoGeometry,byteLength,ptr);const index=new Uint32Array(draco.HEAPF32.buffer,ptr,numIndices).slice();return draco._free(ptr),{array:index,itemSize:1}}(draco,decoder,dracoGeometry));return draco.destroy(dracoGeometry),geometry}(draco,decoder,decoderBuffer,taskConfig),buffers=geometry.attributes.map((attr=>attr.array.buffer));geometry.index&&buffers.push(geometry.index.array.buffer),self.postMessage({type:"decode",id:message.id,geometry:geometry},buffers)}catch(error){console.error(error),self.postMessage({type:"error",id:message.id,error:error.message})}finally{draco.destroy(decoderBuffer),draco.destroy(decoder)}}))}}}var lib=__webpack_require__("./node_modules/@lincode/utils/lib/index.js"),cloneSkinnedMesh=__webpack_require__("./node_modules/lingo3d/lib/display/utils/cloneSkinnedMesh.js"),useLoadingCount=__webpack_require__("./node_modules/lingo3d/lib/states/useLoadingCount.js"),settings=__webpack_require__("./node_modules/lingo3d/lib/api/settings.js"),bytesLoaded=__webpack_require__("./node_modules/lingo3d/lib/display/utils/loaders/bytesLoaded.js"),useEncoding=__webpack_require__("./node_modules/lingo3d/lib/states/useEncoding.js");const loadGLTF_cache=new Map,loadGLTF_loader=new GLTFLoader_GLTFLoader,dracoLoader=new DRACOLoader_DRACOLoader;dracoLoader.setDecoderPath(settings.a.wasmPath),loadGLTF_loader.setDRACOLoader(dracoLoader);__webpack_exports__.default=async(url,clone)=>{const gltf=await Object(lib.e)(loadGLTF_cache,url,(()=>new Promise(((resolve,reject)=>{Object(useLoadingCount.c)(),loadGLTF_loader.load(url,(gltf=>{Object(useLoadingCount.a)();for(const scene of gltf.scenes)"linear"===Object(useEncoding.a)()?scene.traverse((child=>{var _a;(null===(_a=child.material)||void 0===_a?void 0:_a.map)&&(child.material.map.encoding=three_module.vb)})):scene.traverse((child=>{var _a;(null===(_a=child.material)||void 0===_a?void 0:_a.map)&&(child.material.map.encoding=three_module.Cd)}));resolve(gltf)}),bytesLoaded.b,(()=>{Object(useLoadingCount.a)(),reject()}))}))));return clone?Object(cloneSkinnedMesh.a)(gltf.scene,gltf.animations):gltf.scene}}}]);