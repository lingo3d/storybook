(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{"./node_modules/lingo3d/lib/display/core/SimpleObjectManager/PhysicsItem/bvh/bvh.js":function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return MeshBVH})),__webpack_require__.d(__webpack_exports__,"b",(function(){return MeshBVHVisualizer}));var three__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/three/build/three.module.js");const FLOAT32_EPSILON=Math.pow(2,-24);class MeshBVHNode{constructor(){}}function arrayToBox(nodeIndex32,array,target){return target.min.x=array[nodeIndex32],target.min.y=array[nodeIndex32+1],target.min.z=array[nodeIndex32+2],target.max.x=array[nodeIndex32+3],target.max.y=array[nodeIndex32+4],target.max.z=array[nodeIndex32+5],target}function getLongestEdgeIndex(bounds){let splitDimIdx=-1,splitDist=-1/0;for(let i=0;i<3;i++){const dist=bounds[i+3]-bounds[i];dist>splitDist&&(splitDist=dist,splitDimIdx=i)}return splitDimIdx}function copyBounds(source,target){target.set(source)}function unionBounds(a,b,target){let aVal,bVal;for(let d=0;d<3;d++){const d3=d+3;aVal=a[d],bVal=b[d],target[d]=aVal<bVal?aVal:bVal,aVal=a[d3],bVal=b[d3],target[d3]=aVal>bVal?aVal:bVal}}function expandByTriangleBounds(startIndex,triangleBounds,bounds){for(let d=0;d<3;d++){const tCenter=triangleBounds[startIndex+2*d],tHalf=triangleBounds[startIndex+2*d+1],tMin=tCenter-tHalf,tMax=tCenter+tHalf;tMin<bounds[d]&&(bounds[d]=tMin),tMax>bounds[d+3]&&(bounds[d+3]=tMax)}}function computeSurfaceArea(bounds){const d0=bounds[3]-bounds[0],d1=bounds[4]-bounds[1],d2=bounds[5]-bounds[2];return 2*(d0*d1+d1*d2+d2*d0)}function getBounds(triangleBounds,offset,count,target,centroidTarget=null){let minx=1/0,miny=1/0,minz=1/0,maxx=-1/0,maxy=-1/0,maxz=-1/0,cminx=1/0,cminy=1/0,cminz=1/0,cmaxx=-1/0,cmaxy=-1/0,cmaxz=-1/0;const includeCentroid=null!==centroidTarget;for(let i=6*offset,end=6*(offset+count);i<end;i+=6){const cx=triangleBounds[i+0],hx=triangleBounds[i+1],lx=cx-hx,rx=cx+hx;lx<minx&&(minx=lx),rx>maxx&&(maxx=rx),includeCentroid&&cx<cminx&&(cminx=cx),includeCentroid&&cx>cmaxx&&(cmaxx=cx);const cy=triangleBounds[i+2],hy=triangleBounds[i+3],ly=cy-hy,ry=cy+hy;ly<miny&&(miny=ly),ry>maxy&&(maxy=ry),includeCentroid&&cy<cminy&&(cminy=cy),includeCentroid&&cy>cmaxy&&(cmaxy=cy);const cz=triangleBounds[i+4],hz=triangleBounds[i+5],lz=cz-hz,rz=cz+hz;lz<minz&&(minz=lz),rz>maxz&&(maxz=rz),includeCentroid&&cz<cminz&&(cminz=cz),includeCentroid&&cz>cmaxz&&(cmaxz=cz)}target[0]=minx,target[1]=miny,target[2]=minz,target[3]=maxx,target[4]=maxy,target[5]=maxz,includeCentroid&&(centroidTarget[0]=cminx,centroidTarget[1]=cminy,centroidTarget[2]=cminz,centroidTarget[3]=cmaxx,centroidTarget[4]=cmaxy,centroidTarget[5]=cmaxz)}const binsSort=(a,b)=>a.candidate-b.candidate,sahBins=new Array(32).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),leftBounds=new Float32Array(6);function buildTree(geo,options){function triggerProgress(trianglesProcessed){onProgress&&onProgress(trianglesProcessed/totalTriangles)}function splitNode(node,offset,count,centroidBoundingData=null,depth=0){if(!reachedMaxDepth&&depth>=maxDepth&&(reachedMaxDepth=!0,verbose&&(console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`),console.warn(geo))),count<=maxLeafTris||depth>=maxDepth)return triggerProgress(offset),node.offset=offset,node.count=count,node;const split=function getOptimalSplit(nodeBoundingData,centroidBoundingData,triangleBounds,offset,count,strategy){let axis=-1,pos=0;if(0===strategy)axis=getLongestEdgeIndex(centroidBoundingData),-1!==axis&&(pos=(centroidBoundingData[axis]+centroidBoundingData[axis+3])/2);else if(1===strategy)axis=getLongestEdgeIndex(nodeBoundingData),-1!==axis&&(pos=function getAverage(triangleBounds,offset,count,axis){let avg=0;for(let i=offset,end=offset+count;i<end;i++)avg+=triangleBounds[6*i+2*axis];return avg/count}(triangleBounds,offset,count,axis));else if(2===strategy){const rootSurfaceArea=computeSurfaceArea(nodeBoundingData);let bestCost=1.25*count;const cStart=6*offset,cEnd=6*(offset+count);for(let a=0;a<3;a++){const axisLeft=centroidBoundingData[a],binWidth=(centroidBoundingData[a+3]-axisLeft)/32;if(count<8){const truncatedBins=[...sahBins];truncatedBins.length=count;let b=0;for(let c=cStart;c<cEnd;c+=6,b++){const bin=truncatedBins[b];bin.candidate=triangleBounds[c+2*a],bin.count=0;const{bounds:bounds,leftCacheBounds:leftCacheBounds,rightCacheBounds:rightCacheBounds}=bin;for(let d=0;d<3;d++)rightCacheBounds[d]=1/0,rightCacheBounds[d+3]=-1/0,leftCacheBounds[d]=1/0,leftCacheBounds[d+3]=-1/0,bounds[d]=1/0,bounds[d+3]=-1/0;expandByTriangleBounds(c,triangleBounds,bounds)}truncatedBins.sort(binsSort);let splitCount=count;for(let bi=0;bi<splitCount;bi++){const bin=truncatedBins[bi];for(;bi+1<splitCount&&truncatedBins[bi+1].candidate===bin.candidate;)truncatedBins.splice(bi+1,1),splitCount--}for(let c=cStart;c<cEnd;c+=6){const center=triangleBounds[c+2*a];for(let bi=0;bi<splitCount;bi++){const bin=truncatedBins[bi];center>=bin.candidate?expandByTriangleBounds(c,triangleBounds,bin.rightCacheBounds):(expandByTriangleBounds(c,triangleBounds,bin.leftCacheBounds),bin.count++)}}for(let bi=0;bi<splitCount;bi++){const bin=truncatedBins[bi],leftCount=bin.count,rightCount=count-bin.count,leftBounds=bin.leftCacheBounds,rightBounds=bin.rightCacheBounds;let leftProb=0;0!==leftCount&&(leftProb=computeSurfaceArea(leftBounds)/rootSurfaceArea);let rightProb=0;0!==rightCount&&(rightProb=computeSurfaceArea(rightBounds)/rootSurfaceArea);const cost=1+1.25*(leftProb*leftCount+rightProb*rightCount);cost<bestCost&&(axis=a,bestCost=cost,pos=bin.candidate)}}else{for(let i=0;i<32;i++){const bin=sahBins[i];bin.count=0,bin.candidate=axisLeft+binWidth+i*binWidth;const bounds=bin.bounds;for(let d=0;d<3;d++)bounds[d]=1/0,bounds[d+3]=-1/0}for(let c=cStart;c<cEnd;c+=6){let binIndex=~~((triangleBounds[c+2*a]-axisLeft)/binWidth);binIndex>=32&&(binIndex=31);const bin=sahBins[binIndex];bin.count++,expandByTriangleBounds(c,triangleBounds,bin.bounds)}const lastBin=sahBins[31];copyBounds(lastBin.bounds,lastBin.rightCacheBounds);for(let i=30;i>=0;i--){const bin=sahBins[i],nextBin=sahBins[i+1];unionBounds(bin.bounds,nextBin.rightCacheBounds,bin.rightCacheBounds)}let leftCount=0;for(let i=0;i<31;i++){const bin=sahBins[i],binCount=bin.count,bounds=bin.bounds,rightBounds=sahBins[i+1].rightCacheBounds;0!==binCount&&(0===leftCount?copyBounds(bounds,leftBounds):unionBounds(bounds,leftBounds,leftBounds)),leftCount+=binCount;let leftProb=0,rightProb=0;0!==leftCount&&(leftProb=computeSurfaceArea(leftBounds)/rootSurfaceArea);const rightCount=count-leftCount;0!==rightCount&&(rightProb=computeSurfaceArea(rightBounds)/rootSurfaceArea);const cost=1+1.25*(leftProb*leftCount+rightProb*rightCount);cost<bestCost&&(axis=a,bestCost=cost,pos=bin.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);return{axis:axis,pos:pos}}(node.boundingData,centroidBoundingData,triangleBounds,offset,count,strategy);if(-1===split.axis)return triggerProgress(offset),node.offset=offset,node.count=count,node;const splitOffset=function partition(index,triangleBounds,offset,count,split){let left=offset,right=offset+count-1;const pos=split.pos,axisOffset=2*split.axis;for(;;){for(;left<=right&&triangleBounds[6*left+axisOffset]<pos;)left++;for(;left<=right&&triangleBounds[6*right+axisOffset]>=pos;)right--;if(!(left<right))return left;for(let i=0;i<3;i++){let t0=index[3*left+i];index[3*left+i]=index[3*right+i],index[3*right+i]=t0;let t1=triangleBounds[6*left+2*i+0];triangleBounds[6*left+2*i+0]=triangleBounds[6*right+2*i+0],triangleBounds[6*right+2*i+0]=t1;let t2=triangleBounds[6*left+2*i+1];triangleBounds[6*left+2*i+1]=triangleBounds[6*right+2*i+1],triangleBounds[6*right+2*i+1]=t2}left++,right--}}(indexArray,triangleBounds,offset,count,split);if(splitOffset===offset||splitOffset===offset+count)triggerProgress(offset),node.offset=offset,node.count=count;else{node.splitAxis=split.axis;const left=new MeshBVHNode,lstart=offset,lcount=splitOffset-offset;node.left=left,left.boundingData=new Float32Array(6),getBounds(triangleBounds,lstart,lcount,left.boundingData,cacheCentroidBoundingData),splitNode(left,lstart,lcount,cacheCentroidBoundingData,depth+1);const right=new MeshBVHNode,rstart=splitOffset,rcount=count-lcount;node.right=right,right.boundingData=new Float32Array(6),getBounds(triangleBounds,rstart,rcount,right.boundingData,cacheCentroidBoundingData),splitNode(right,rstart,rcount,cacheCentroidBoundingData,depth+1)}return node}!function ensureIndex(geo,options){if(!geo.index){const vertexCount=geo.attributes.position.count,BufferConstructor=options.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let index;index=vertexCount>65535?new Uint32Array(new BufferConstructor(4*vertexCount)):new Uint16Array(new BufferConstructor(2*vertexCount)),geo.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.o(index,1));for(let i=0;i<vertexCount;i++)index[i]=i}}(geo,options);const fullBounds=new Float32Array(6),cacheCentroidBoundingData=new Float32Array(6),triangleBounds=function computeTriangleBounds(geo,fullBounds){const posAttr=geo.attributes.position,posArr=posAttr.array,index=geo.index.array,triCount=index.length/3,triangleBounds=new Float32Array(6*triCount),bufferOffset=posAttr.offset||0;let stride=3;posAttr.isInterleavedBufferAttribute&&(stride=posAttr.data.stride);for(let tri=0;tri<triCount;tri++){const tri3=3*tri,tri6=6*tri,ai=index[tri3+0]*stride+bufferOffset,bi=index[tri3+1]*stride+bufferOffset,ci=index[tri3+2]*stride+bufferOffset;for(let el=0;el<3;el++){const a=posArr[ai+el],b=posArr[bi+el],c=posArr[ci+el];let min=a;b<min&&(min=b),c<min&&(min=c);let max=a;b>max&&(max=b),c>max&&(max=c);const halfExtents=(max-min)/2,el2=2*el;triangleBounds[tri6+el2+0]=min+halfExtents,triangleBounds[tri6+el2+1]=halfExtents+(Math.abs(min)+halfExtents)*FLOAT32_EPSILON,min<fullBounds[el]&&(fullBounds[el]=min),max>fullBounds[el+3]&&(fullBounds[el+3]=max)}}return triangleBounds}(geo,fullBounds),indexArray=geo.index.array,maxDepth=options.maxDepth,verbose=options.verbose,maxLeafTris=options.maxLeafTris,strategy=options.strategy,onProgress=options.onProgress,totalTriangles=geo.index.count/3;let reachedMaxDepth=!1;const roots=[],ranges=function getRootIndexRanges(geo){if(!geo.groups||!geo.groups.length)return[{offset:0,count:geo.index.count/3}];const ranges=[],rangeBoundaries=new Set;for(const group of geo.groups)rangeBoundaries.add(group.start),rangeBoundaries.add(group.start+group.count);const sortedBoundaries=Array.from(rangeBoundaries.values()).sort(((a,b)=>a-b));for(let i=0;i<sortedBoundaries.length-1;i++){const start=sortedBoundaries[i],end=sortedBoundaries[i+1];ranges.push({offset:start/3,count:(end-start)/3})}return ranges}(geo);if(1===ranges.length){const range=ranges[0],root=new MeshBVHNode;root.boundingData=fullBounds,function getCentroidBounds(triangleBounds,offset,count,centroidTarget){let cminx=1/0,cminy=1/0,cminz=1/0,cmaxx=-1/0,cmaxy=-1/0,cmaxz=-1/0;for(let i=6*offset,end=6*(offset+count);i<end;i+=6){const cx=triangleBounds[i+0];cx<cminx&&(cminx=cx),cx>cmaxx&&(cmaxx=cx);const cy=triangleBounds[i+2];cy<cminy&&(cminy=cy),cy>cmaxy&&(cmaxy=cy);const cz=triangleBounds[i+4];cz<cminz&&(cminz=cz),cz>cmaxz&&(cmaxz=cz)}centroidTarget[0]=cminx,centroidTarget[1]=cminy,centroidTarget[2]=cminz,centroidTarget[3]=cmaxx,centroidTarget[4]=cmaxy,centroidTarget[5]=cmaxz}(triangleBounds,range.offset,range.count,cacheCentroidBoundingData),splitNode(root,range.offset,range.count,cacheCentroidBoundingData),roots.push(root)}else for(let range of ranges){const root=new MeshBVHNode;root.boundingData=new Float32Array(6),getBounds(triangleBounds,range.offset,range.count,root.boundingData,cacheCentroidBoundingData),splitNode(root,range.offset,range.count,cacheCentroidBoundingData),roots.push(root)}return roots}class SeparatingAxisBounds{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(points,field){let min=1/0,max=-1/0;for(let i=0,l=points.length;i<l;i++){const val=points[i][field];min=val<min?val:min,max=val>max?val:max}this.min=min,this.max=max}setFromPoints(axis,points){let min=1/0,max=-1/0;for(let i=0,l=points.length;i<l;i++){const p=points[i],val=axis.dot(p);min=val<min?val:min,max=val>max?val:max}this.min=min,this.max=max}isSeparated(other){return this.min>other.max||other.min>this.max}}SeparatingAxisBounds.prototype.setFromBox=function(){const p=new three__WEBPACK_IMPORTED_MODULE_0__.ud;return function setFromBox(axis,box){const boxMin=box.min,boxMax=box.max;let min=1/0,max=-1/0;for(let x=0;x<=1;x++)for(let y=0;y<=1;y++)for(let z=0;z<=1;z++){p.x=boxMin.x*x+boxMax.x*(1-x),p.y=boxMin.y*y+boxMax.y*(1-y),p.z=boxMin.z*z+boxMax.z*(1-z);const val=axis.dot(p);min=Math.min(val,min),max=Math.max(val,max)}this.min=min,this.max=max}}();!function(){const cacheSatBounds=new SeparatingAxisBounds}();const closestPointLineToLine=function(){const dir1=new three__WEBPACK_IMPORTED_MODULE_0__.ud,dir2=new three__WEBPACK_IMPORTED_MODULE_0__.ud,v02=new three__WEBPACK_IMPORTED_MODULE_0__.ud;return function closestPointLineToLine(l1,l2,result){const v0=l1.start,v10=dir1,v2=l2.start,v32=dir2;v02.subVectors(v0,v2),dir1.subVectors(l1.end,l2.start),dir2.subVectors(l2.end,l2.start);const d0232=v02.dot(v32),d3210=v32.dot(v10),d3232=v32.dot(v32),d0210=v02.dot(v10),denom=v10.dot(v10)*d3232-d3210*d3210;let d,d2;d=0!==denom?(d0232*d3210-d0210*d3232)/denom:0,d2=(d0232+d*d3210)/d3232,result.x=d,result.y=d2}}(),closestPointsSegmentToSegment=function(){const paramResult=new three__WEBPACK_IMPORTED_MODULE_0__.td,temp1=new three__WEBPACK_IMPORTED_MODULE_0__.ud,temp2=new three__WEBPACK_IMPORTED_MODULE_0__.ud;return function closestPointsSegmentToSegment(l1,l2,target1,target2){closestPointLineToLine(l1,l2,paramResult);let d=paramResult.x,d2=paramResult.y;if(d>=0&&d<=1&&d2>=0&&d2<=1)return l1.at(d,target1),void l2.at(d2,target2);if(d>=0&&d<=1)return d2<0?l2.at(0,target2):l2.at(1,target2),void l1.closestPointToPoint(target2,!0,target1);if(d2>=0&&d2<=1)return d<0?l1.at(0,target1):l1.at(1,target1),void l2.closestPointToPoint(target1,!0,target2);{let p,p2;p=d<0?l1.start:l1.end,p2=d2<0?l2.start:l2.end;const closestPoint=temp1,closestPoint2=temp2;return l1.closestPointToPoint(p2,!0,temp1),l2.closestPointToPoint(p,!0,temp2),closestPoint.distanceToSquared(p2)<=closestPoint2.distanceToSquared(p)?(target1.copy(closestPoint),void target2.copy(p2)):(target1.copy(p),void target2.copy(closestPoint2))}}}(),sphereIntersectTriangle=function(){const closestPointTemp=new three__WEBPACK_IMPORTED_MODULE_0__.ud,projectedPointTemp=new three__WEBPACK_IMPORTED_MODULE_0__.ud,planeTemp=new three__WEBPACK_IMPORTED_MODULE_0__.mc,lineTemp=new three__WEBPACK_IMPORTED_MODULE_0__.rb;return function sphereIntersectTriangle(sphere,triangle){const{radius:radius,center:center}=sphere,{a:a,b:b,c:c}=triangle;lineTemp.start=a,lineTemp.end=b;if(lineTemp.closestPointToPoint(center,!0,closestPointTemp).distanceTo(center)<=radius)return!0;lineTemp.start=a,lineTemp.end=c;if(lineTemp.closestPointToPoint(center,!0,closestPointTemp).distanceTo(center)<=radius)return!0;lineTemp.start=b,lineTemp.end=c;if(lineTemp.closestPointToPoint(center,!0,closestPointTemp).distanceTo(center)<=radius)return!0;const plane=triangle.getPlane(planeTemp);if(Math.abs(plane.distanceToPoint(center))<=radius){const pp=plane.projectPoint(center,projectedPointTemp);if(triangle.containsPoint(pp))return!0}return!1}}();class SeparatingAxisTriangle extends three__WEBPACK_IMPORTED_MODULE_0__.hd{constructor(...args){super(...args),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new three__WEBPACK_IMPORTED_MODULE_0__.ud)),this.satBounds=new Array(4).fill().map((()=>new SeparatingAxisBounds)),this.points=[this.a,this.b,this.c],this.sphere=new three__WEBPACK_IMPORTED_MODULE_0__.Rc,this.plane=new three__WEBPACK_IMPORTED_MODULE_0__.mc,this.needsUpdate=!1}intersectsSphere(sphere){return sphereIntersectTriangle(sphere,this)}update(){const a=this.a,b=this.b,c=this.c,points=this.points,satAxes=this.satAxes,satBounds=this.satBounds,axis0=satAxes[0],sab0=satBounds[0];this.getNormal(axis0),sab0.setFromPoints(axis0,points);const axis1=satAxes[1],sab1=satBounds[1];axis1.subVectors(a,b),sab1.setFromPoints(axis1,points);const axis2=satAxes[2],sab2=satBounds[2];axis2.subVectors(b,c),sab2.setFromPoints(axis2,points);const axis3=satAxes[3],sab3=satBounds[3];axis3.subVectors(c,a),sab3.setFromPoints(axis3,points),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(axis0,a),this.needsUpdate=!1}}SeparatingAxisTriangle.prototype.closestPointToSegment=function(){const point1=new three__WEBPACK_IMPORTED_MODULE_0__.ud,point2=new three__WEBPACK_IMPORTED_MODULE_0__.ud,edge=new three__WEBPACK_IMPORTED_MODULE_0__.rb;return function distanceToSegment(segment,target1=null,target2=null){const{start:start,end:end}=segment,points=this.points;let distSq,closestDistanceSq=1/0;for(let i=0;i<3;i++){const nexti=(i+1)%3;edge.start.copy(points[i]),edge.end.copy(points[nexti]),closestPointsSegmentToSegment(edge,segment,point1,point2),distSq=point1.distanceToSquared(point2),distSq<closestDistanceSq&&(closestDistanceSq=distSq,target1&&target1.copy(point1),target2&&target2.copy(point2))}return this.closestPointToPoint(start,point1),distSq=start.distanceToSquared(point1),distSq<closestDistanceSq&&(closestDistanceSq=distSq,target1&&target1.copy(point1),target2&&target2.copy(start)),this.closestPointToPoint(end,point1),distSq=end.distanceToSquared(point1),distSq<closestDistanceSq&&(closestDistanceSq=distSq,target1&&target1.copy(point1),target2&&target2.copy(end)),Math.sqrt(closestDistanceSq)}}(),SeparatingAxisTriangle.prototype.intersectsTriangle=function(){const saTri2=new SeparatingAxisTriangle,arr1=new Array(3),arr2=new Array(3),cachedSatBounds=new SeparatingAxisBounds,cachedSatBounds2=new SeparatingAxisBounds,cachedAxis=new three__WEBPACK_IMPORTED_MODULE_0__.ud,dir1=new three__WEBPACK_IMPORTED_MODULE_0__.ud,dir2=new three__WEBPACK_IMPORTED_MODULE_0__.ud,tempDir=new three__WEBPACK_IMPORTED_MODULE_0__.ud,edge=new three__WEBPACK_IMPORTED_MODULE_0__.rb,edge1=new three__WEBPACK_IMPORTED_MODULE_0__.rb,edge2=new three__WEBPACK_IMPORTED_MODULE_0__.rb;return function intersectsTriangle(other,target=null){this.needsUpdate&&this.update(),other.isSeparatingAxisTriangle?other.needsUpdate&&other.update():(saTri2.copy(other),saTri2.update(),other=saTri2);const satBounds1=this.satBounds,satAxes1=this.satAxes;arr2[0]=other.a,arr2[1]=other.b,arr2[2]=other.c;for(let i=0;i<4;i++){const sb=satBounds1[i],sa=satAxes1[i];if(cachedSatBounds.setFromPoints(sa,arr2),sb.isSeparated(cachedSatBounds))return!1}const satBounds2=other.satBounds,satAxes2=other.satAxes;arr1[0]=this.a,arr1[1]=this.b,arr1[2]=this.c;for(let i=0;i<4;i++){const sb=satBounds2[i],sa=satAxes2[i];if(cachedSatBounds.setFromPoints(sa,arr1),sb.isSeparated(cachedSatBounds))return!1}for(let i=0;i<4;i++){const sa1=satAxes1[i];for(let i2=0;i2<4;i2++){const sa2=satAxes2[i2];if(cachedAxis.crossVectors(sa1,sa2),cachedSatBounds.setFromPoints(cachedAxis,arr1),cachedSatBounds2.setFromPoints(cachedAxis,arr2),cachedSatBounds.isSeparated(cachedSatBounds2))return!1}}if(target){const plane1=this.plane,plane2=other.plane;if(Math.abs(plane1.normal.dot(plane2.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),target.start.set(0,0,0),target.end.set(0,0,0);else{const points1=this.points;let found1=!1;for(let i=0;i<3;i++){const p1=points1[i],p2=points1[(i+1)%3];if(edge.start.copy(p1),edge.end.copy(p2),plane2.intersectLine(edge,found1?edge1.start:edge1.end)){if(found1)break;found1=!0}}const points2=other.points;let found2=!1;for(let i=0;i<3;i++){const p1=points2[i],p2=points2[(i+1)%3];if(edge.start.copy(p1),edge.end.copy(p2),plane1.intersectLine(edge,found2?edge2.start:edge2.end)){if(found2)break;found2=!0}}if(edge1.delta(dir1),edge2.delta(dir2),dir1.dot(dir2)<0){let tmp=edge2.start;edge2.start=edge2.end,edge2.end=tmp}tempDir.subVectors(edge1.start,edge2.start),tempDir.dot(dir1)>0?target.start.copy(edge1.start):target.start.copy(edge2.start),tempDir.subVectors(edge1.end,edge2.end),tempDir.dot(dir1)<0?target.end.copy(edge1.end):target.end.copy(edge2.end)}}return!0}}(),SeparatingAxisTriangle.prototype.distanceToPoint=function(){const target=new three__WEBPACK_IMPORTED_MODULE_0__.ud;return function distanceToPoint(point){return this.closestPointToPoint(point,target),point.distanceTo(target)}}(),SeparatingAxisTriangle.prototype.distanceToTriangle=function(){const point=new three__WEBPACK_IMPORTED_MODULE_0__.ud,point2=new three__WEBPACK_IMPORTED_MODULE_0__.ud,cornerFields=["a","b","c"],line1=new three__WEBPACK_IMPORTED_MODULE_0__.rb,line2=new three__WEBPACK_IMPORTED_MODULE_0__.rb;return function distanceToTriangle(other,target1=null,target2=null){const lineTarget=target1||target2?line1:null;if(this.intersectsTriangle(other,lineTarget))return(target1||target2)&&(target1&&lineTarget.getCenter(target1),target2&&lineTarget.getCenter(target2)),0;let closestDistanceSq=1/0;for(let i=0;i<3;i++){let dist;const field=cornerFields[i],otherVec=other[field];this.closestPointToPoint(otherVec,point),dist=otherVec.distanceToSquared(point),dist<closestDistanceSq&&(closestDistanceSq=dist,target1&&target1.copy(point),target2&&target2.copy(otherVec));const thisVec=this[field];other.closestPointToPoint(thisVec,point),dist=thisVec.distanceToSquared(point),dist<closestDistanceSq&&(closestDistanceSq=dist,target1&&target1.copy(thisVec),target2&&target2.copy(point))}for(let i=0;i<3;i++){const f11=cornerFields[i],f12=cornerFields[(i+1)%3];line1.set(this[f11],this[f12]);for(let i2=0;i2<3;i2++){const f21=cornerFields[i2],f22=cornerFields[(i2+1)%3];line2.set(other[f21],other[f22]),closestPointsSegmentToSegment(line1,line2,point,point2);const dist=point.distanceToSquared(point2);dist<closestDistanceSq&&(closestDistanceSq=dist,target1&&target1.copy(point),target2&&target2.copy(point2))}}return Math.sqrt(closestDistanceSq)}}();class OrientedBox extends three__WEBPACK_IMPORTED_MODULE_0__.k{constructor(...args){super(...args),this.isOrientedBox=!0,this.matrix=new three__WEBPACK_IMPORTED_MODULE_0__.Kb,this.invMatrix=new three__WEBPACK_IMPORTED_MODULE_0__.Kb,this.points=new Array(8).fill().map((()=>new three__WEBPACK_IMPORTED_MODULE_0__.ud)),this.satAxes=new Array(3).fill().map((()=>new three__WEBPACK_IMPORTED_MODULE_0__.ud)),this.satBounds=new Array(3).fill().map((()=>new SeparatingAxisBounds)),this.alignedSatBounds=new Array(3).fill().map((()=>new SeparatingAxisBounds)),this.needsUpdate=!1}set(min,max,matrix){super.set(min,max),this.matrix=matrix,this.needsUpdate=!0}copy(other){super.copy(other),this.matrix.copy(other.matrix),this.needsUpdate=!0}}OrientedBox.prototype.update=function update(){const matrix=this.matrix,min=this.min,max=this.max,points=this.points;for(let x=0;x<=1;x++)for(let y=0;y<=1;y++)for(let z=0;z<=1;z++){const v=points[1*x|2*y|4*z];v.x=x?max.x:min.x,v.y=y?max.y:min.y,v.z=z?max.z:min.z,v.applyMatrix4(matrix)}const satBounds=this.satBounds,satAxes=this.satAxes,minVec=points[0];for(let i=0;i<3;i++){const axis=satAxes[i],sb=satBounds[i],pi=points[1<<i];axis.subVectors(minVec,pi),sb.setFromPoints(axis,points)}const alignedSatBounds=this.alignedSatBounds;alignedSatBounds[0].setFromPointsField(points,"x"),alignedSatBounds[1].setFromPointsField(points,"y"),alignedSatBounds[2].setFromPointsField(points,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},OrientedBox.prototype.intersectsBox=function(){const aabbBounds=new SeparatingAxisBounds;return function intersectsBox(box){this.needsUpdate&&this.update();const min=box.min,max=box.max,satBounds=this.satBounds,satAxes=this.satAxes,alignedSatBounds=this.alignedSatBounds;if(aabbBounds.min=min.x,aabbBounds.max=max.x,alignedSatBounds[0].isSeparated(aabbBounds))return!1;if(aabbBounds.min=min.y,aabbBounds.max=max.y,alignedSatBounds[1].isSeparated(aabbBounds))return!1;if(aabbBounds.min=min.z,aabbBounds.max=max.z,alignedSatBounds[2].isSeparated(aabbBounds))return!1;for(let i=0;i<3;i++){const axis=satAxes[i],sb=satBounds[i];if(aabbBounds.setFromBox(axis,box),sb.isSeparated(aabbBounds))return!1}return!0}}(),OrientedBox.prototype.intersectsTriangle=function(){const saTri=new SeparatingAxisTriangle,pointsArr=new Array(3),cachedSatBounds=new SeparatingAxisBounds,cachedSatBounds2=new SeparatingAxisBounds,cachedAxis=new three__WEBPACK_IMPORTED_MODULE_0__.ud;return function intersectsTriangle(triangle){this.needsUpdate&&this.update(),triangle.isSeparatingAxisTriangle?triangle.needsUpdate&&triangle.update():(saTri.copy(triangle),saTri.update(),triangle=saTri);const satBounds=this.satBounds,satAxes=this.satAxes;pointsArr[0]=triangle.a,pointsArr[1]=triangle.b,pointsArr[2]=triangle.c;for(let i=0;i<3;i++){const sb=satBounds[i],sa=satAxes[i];if(cachedSatBounds.setFromPoints(sa,pointsArr),sb.isSeparated(cachedSatBounds))return!1}const triSatBounds=triangle.satBounds,triSatAxes=triangle.satAxes,points=this.points;for(let i=0;i<3;i++){const sb=triSatBounds[i],sa=triSatAxes[i];if(cachedSatBounds.setFromPoints(sa,points),sb.isSeparated(cachedSatBounds))return!1}for(let i=0;i<3;i++){const sa1=satAxes[i];for(let i2=0;i2<4;i2++){const sa2=triSatAxes[i2];if(cachedAxis.crossVectors(sa1,sa2),cachedSatBounds.setFromPoints(cachedAxis,pointsArr),cachedSatBounds2.setFromPoints(cachedAxis,points),cachedSatBounds.isSeparated(cachedSatBounds2))return!1}}return!0}}(),OrientedBox.prototype.closestPointToPoint=function closestPointToPoint(point,target1){return this.needsUpdate&&this.update(),target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),target1},OrientedBox.prototype.distanceToPoint=function(){const target=new three__WEBPACK_IMPORTED_MODULE_0__.ud;return function distanceToPoint(point){return this.closestPointToPoint(point,target),point.distanceTo(target)}}(),OrientedBox.prototype.distanceToBox=function(){const xyzFields=["x","y","z"],segments1=new Array(12).fill().map((()=>new three__WEBPACK_IMPORTED_MODULE_0__.rb)),segments2=new Array(12).fill().map((()=>new three__WEBPACK_IMPORTED_MODULE_0__.rb)),point1=new three__WEBPACK_IMPORTED_MODULE_0__.ud,point2=new three__WEBPACK_IMPORTED_MODULE_0__.ud;return function distanceToBox(box,threshold=0,target1=null,target2=null){if(this.needsUpdate&&this.update(),this.intersectsBox(box))return(target1||target2)&&(box.getCenter(point2),this.closestPointToPoint(point2,point1),box.closestPointToPoint(point1,point2),target1&&target1.copy(point1),target2&&target2.copy(point2)),0;const threshold2=threshold*threshold,min=box.min,max=box.max,points=this.points;let closestDistanceSq=1/0;for(let i=0;i<8;i++){const p=points[i];point2.copy(p).clamp(min,max);const dist=p.distanceToSquared(point2);if(dist<closestDistanceSq&&(closestDistanceSq=dist,target1&&target1.copy(p),target2&&target2.copy(point2),dist<threshold2))return Math.sqrt(dist)}let count=0;for(let i=0;i<3;i++)for(let i1=0;i1<=1;i1++)for(let i2=0;i2<=1;i2++){const nextIndex=(i+1)%3,nextIndex2=(i+2)%3,index2=1<<i|i1<<nextIndex|i2<<nextIndex2,p1=points[i1<<nextIndex|i2<<nextIndex2],p2=points[index2];segments1[count].set(p1,p2);const f1=xyzFields[i],f2=xyzFields[nextIndex],f3=xyzFields[nextIndex2],line2=segments2[count],start=line2.start,end=line2.end;start[f1]=min[f1],start[f2]=i1?min[f2]:max[f2],start[f3]=i2?min[f3]:max[f2],end[f1]=max[f1],end[f2]=i1?min[f2]:max[f2],end[f3]=i2?min[f3]:max[f2],count++}for(let x=0;x<=1;x++)for(let y=0;y<=1;y++)for(let z=0;z<=1;z++){point2.x=x?max.x:min.x,point2.y=y?max.y:min.y,point2.z=z?max.z:min.z,this.closestPointToPoint(point2,point1);const dist=point2.distanceToSquared(point1);if(dist<closestDistanceSq&&(closestDistanceSq=dist,target1&&target1.copy(point1),target2&&target2.copy(point2),dist<threshold2))return Math.sqrt(dist)}for(let i=0;i<12;i++){const l1=segments1[i];for(let i2=0;i2<12;i2++){const l2=segments2[i2];closestPointsSegmentToSegment(l1,l2,point1,point2);const dist=point1.distanceToSquared(point2);if(dist<closestDistanceSq&&(closestDistanceSq=dist,target1&&target1.copy(point1),target2&&target2.copy(point2),dist<threshold2))return Math.sqrt(dist)}}return Math.sqrt(closestDistanceSq)}}();const vA=new three__WEBPACK_IMPORTED_MODULE_0__.ud,vB=new three__WEBPACK_IMPORTED_MODULE_0__.ud,vC=new three__WEBPACK_IMPORTED_MODULE_0__.ud,uvA=new three__WEBPACK_IMPORTED_MODULE_0__.td,uvB=new three__WEBPACK_IMPORTED_MODULE_0__.td,uvC=new three__WEBPACK_IMPORTED_MODULE_0__.td,intersectionPoint=new three__WEBPACK_IMPORTED_MODULE_0__.ud;function checkBufferGeometryIntersection(ray,position,uv,a,b,c,side){vA.fromBufferAttribute(position,a),vB.fromBufferAttribute(position,b),vC.fromBufferAttribute(position,c);const intersection=function checkIntersection(ray,pA,pB,pC,point,side){let intersect;return intersect=side===three__WEBPACK_IMPORTED_MODULE_0__.g?ray.intersectTriangle(pC,pB,pA,!0,point):ray.intersectTriangle(pA,pB,pC,side!==three__WEBPACK_IMPORTED_MODULE_0__.M,point),null===intersect?null:{distance:ray.origin.distanceTo(point),point:point.clone()}}(ray,vA,vB,vC,intersectionPoint,side);if(intersection){uv&&(uvA.fromBufferAttribute(uv,a),uvB.fromBufferAttribute(uv,b),uvC.fromBufferAttribute(uv,c),intersection.uv=three__WEBPACK_IMPORTED_MODULE_0__.hd.getUV(intersectionPoint,vA,vB,vC,uvA,uvB,uvC,new three__WEBPACK_IMPORTED_MODULE_0__.td));const face={a:a,b:b,c:c,normal:new three__WEBPACK_IMPORTED_MODULE_0__.ud,materialIndex:0};three__WEBPACK_IMPORTED_MODULE_0__.hd.getNormal(vA,vB,vC,face.normal),intersection.face=face,intersection.faceIndex=a}return intersection}function intersectTri(geo,side,ray,tri,intersections){const triOffset=3*tri,a=geo.index.getX(triOffset),b=geo.index.getX(triOffset+1),c=geo.index.getX(triOffset+2),intersection=checkBufferGeometryIntersection(ray,geo.attributes.position,geo.attributes.uv,a,b,c,side);return intersection?(intersection.faceIndex=tri,intersections&&intersections.push(intersection),intersection):null}function convertRaycastIntersect(hit,object,raycaster){return null===hit?null:(hit.point.applyMatrix4(object.matrixWorld),hit.distance=hit.point.distanceTo(raycaster.ray.origin),hit.object=object,hit.distance<raycaster.near||hit.distance>raycaster.far?null:hit)}function setTriangle(tri,i,index,pos){const ta=tri.a,tb=tri.b,tc=tri.c;let i0=i,i1=i+1,i2=i+2;index&&(i0=index.getX(i),i1=index.getX(i+1),i2=index.getX(i+2)),ta.x=pos.getX(i0),ta.y=pos.getY(i0),ta.z=pos.getZ(i0),tb.x=pos.getX(i1),tb.y=pos.getY(i1),tb.z=pos.getZ(i1),tc.x=pos.getX(i2),tc.y=pos.getY(i2),tc.z=pos.getZ(i2)}function iterateOverTriangles(offset,count,geometry,intersectsTriangleFunc,contained,depth,triangle){const index=geometry.index,pos=geometry.attributes.position;for(let i=offset,l=count+offset;i<l;i++)if(setTriangle(triangle,3*i,index,pos),triangle.needsUpdate=!0,intersectsTriangleFunc(triangle,i,contained,depth))return!0;return!1}class PrimitivePool{constructor(getNewPrimitive){this._getNewPrimitive=getNewPrimitive,this._primitives=[]}getPrimitive(){const primitives=this._primitives;return 0===primitives.length?this._getNewPrimitive():primitives.pop()}releasePrimitive(primitive){this._primitives.push(primitive)}}function IS_LEAF(n16,uint16Array){return 65535===uint16Array[n16+15]}function OFFSET(n32,uint32Array){return uint32Array[n32+6]}function COUNT(n16,uint16Array){return uint16Array[n16+14]}function LEFT_NODE(n32){return n32+8}function RIGHT_NODE(n32,uint32Array){return uint32Array[n32+6]}function SPLIT_AXIS(n32,uint32Array){return uint32Array[n32+7]}const boundingBox$1=new three__WEBPACK_IMPORTED_MODULE_0__.k,boxIntersection=new three__WEBPACK_IMPORTED_MODULE_0__.ud,xyzFields=["x","y","z"];function raycast(nodeIndex32,geometry,side,ray,intersects){let nodeIndex16=2*nodeIndex32,float32Array=_float32Array,uint16Array=_uint16Array,uint32Array=_uint32Array;if(IS_LEAF(nodeIndex16,uint16Array)){!function intersectTris(geo,side,ray,offset,count,intersections){for(let i=offset,end=offset+count;i<end;i++)intersectTri(geo,side,ray,i,intersections)}(geometry,side,ray,OFFSET(nodeIndex32,uint32Array),COUNT(nodeIndex16,uint16Array),intersects)}else{const leftIndex=LEFT_NODE(nodeIndex32);intersectRay(leftIndex,float32Array,ray,boxIntersection)&&raycast(leftIndex,geometry,side,ray,intersects);const rightIndex=RIGHT_NODE(nodeIndex32,uint32Array);intersectRay(rightIndex,float32Array,ray,boxIntersection)&&raycast(rightIndex,geometry,side,ray,intersects)}}function raycastFirst(nodeIndex32,geometry,side,ray){let nodeIndex16=2*nodeIndex32,float32Array=_float32Array,uint16Array=_uint16Array,uint32Array=_uint32Array;if(IS_LEAF(nodeIndex16,uint16Array)){return function intersectClosestTri(geo,side,ray,offset,count){let dist=1/0,res=null;for(let i=offset,end=offset+count;i<end;i++){const intersection=intersectTri(geo,side,ray,i);intersection&&intersection.distance<dist&&(res=intersection,dist=intersection.distance)}return res}(geometry,side,ray,OFFSET(nodeIndex32,uint32Array),COUNT(nodeIndex16,uint16Array))}{const splitAxis=SPLIT_AXIS(nodeIndex32,uint32Array),xyzAxis=xyzFields[splitAxis],leftToRight=ray.direction[xyzAxis]>=0;let c1,c2;leftToRight?(c1=LEFT_NODE(nodeIndex32),c2=RIGHT_NODE(nodeIndex32,uint32Array)):(c1=RIGHT_NODE(nodeIndex32,uint32Array),c2=LEFT_NODE(nodeIndex32));const c1Result=intersectRay(c1,float32Array,ray,boxIntersection)?raycastFirst(c1,geometry,side,ray):null;if(c1Result){const point=c1Result.point[xyzAxis];if(leftToRight?point<=float32Array[c2+splitAxis]:point>=float32Array[c2+splitAxis+3])return c1Result}const c2Result=intersectRay(c2,float32Array,ray,boxIntersection)?raycastFirst(c2,geometry,side,ray):null;return c1Result&&c2Result?c1Result.distance<=c2Result.distance?c1Result:c2Result:c1Result||c2Result||null}}const shapecast=function(){let _box1,_box2;const boxStack=[],boxPool=new PrimitivePool((()=>new three__WEBPACK_IMPORTED_MODULE_0__.k));return function shapecast(...args){_box1=boxPool.getPrimitive(),_box2=boxPool.getPrimitive(),boxStack.push(_box1,_box2);const result=shapecastTraverse(...args);boxPool.releasePrimitive(_box1),boxPool.releasePrimitive(_box2),boxStack.pop(),boxStack.pop();const length=boxStack.length;return length>0&&(_box2=boxStack[length-1],_box1=boxStack[length-2]),result};function shapecastTraverse(nodeIndex32,geometry,intersectsBoundsFunc,intersectsRangeFunc,nodeScoreFunc=null,nodeIndexByteOffset=0,depth=0){function getLeftOffset(nodeIndex32){let nodeIndex16=2*nodeIndex32,uint16Array=_uint16Array,uint32Array=_uint32Array;for(;!IS_LEAF(nodeIndex16,uint16Array);)nodeIndex16=2*(nodeIndex32=LEFT_NODE(nodeIndex32));return OFFSET(nodeIndex32,uint32Array)}function getRightEndOffset(nodeIndex32){let nodeIndex16=2*nodeIndex32,uint16Array=_uint16Array,uint32Array=_uint32Array;for(;!IS_LEAF(nodeIndex16,uint16Array);)nodeIndex16=2*(nodeIndex32=RIGHT_NODE(nodeIndex32,uint32Array));return OFFSET(nodeIndex32,uint32Array)+COUNT(nodeIndex16,uint16Array)}let nodeIndex16=2*nodeIndex32,float32Array=_float32Array,uint16Array=_uint16Array,uint32Array=_uint32Array;if(IS_LEAF(nodeIndex16,uint16Array)){const offset=OFFSET(nodeIndex32,uint32Array),count=COUNT(nodeIndex16,uint16Array);return arrayToBox(nodeIndex32,float32Array,_box1),intersectsRangeFunc(offset,count,!1,depth,nodeIndexByteOffset+nodeIndex32,_box1)}{const left=LEFT_NODE(nodeIndex32),right=RIGHT_NODE(nodeIndex32,uint32Array);let score1,score2,box1,box2,c1=left,c2=right;if(nodeScoreFunc&&(box1=_box1,box2=_box2,arrayToBox(c1,float32Array,box1),arrayToBox(c2,float32Array,box2),score1=nodeScoreFunc(box1),score2=nodeScoreFunc(box2),score2<score1)){c1=right,c2=left;const temp=score1;score1=score2,score2=temp,box1=box2}box1||(box1=_box1,arrayToBox(c1,float32Array,box1));const c1Intersection=intersectsBoundsFunc(box1,IS_LEAF(2*c1,uint16Array),score1,depth+1,nodeIndexByteOffset+c1);let c1StopTraversal;if(2===c1Intersection){const offset=getLeftOffset(c1);c1StopTraversal=intersectsRangeFunc(offset,getRightEndOffset(c1)-offset,!0,depth+1,nodeIndexByteOffset+c1,box1)}else c1StopTraversal=c1Intersection&&shapecastTraverse(c1,geometry,intersectsBoundsFunc,intersectsRangeFunc,nodeScoreFunc,nodeIndexByteOffset,depth+1);if(c1StopTraversal)return!0;box2=_box2,arrayToBox(c2,float32Array,box2);const c2Intersection=intersectsBoundsFunc(box2,IS_LEAF(2*c2,uint16Array),score2,depth+1,nodeIndexByteOffset+c2);let c2StopTraversal;if(2===c2Intersection){const offset=getLeftOffset(c2);c2StopTraversal=intersectsRangeFunc(offset,getRightEndOffset(c2)-offset,!0,depth+1,nodeIndexByteOffset+c2,box2)}else c2StopTraversal=c2Intersection&&shapecastTraverse(c2,geometry,intersectsBoundsFunc,intersectsRangeFunc,nodeScoreFunc,nodeIndexByteOffset,depth+1);return!!c2StopTraversal}}}(),intersectsGeometry=function(){const triangle=new SeparatingAxisTriangle,triangle2=new SeparatingAxisTriangle,invertedMat=new three__WEBPACK_IMPORTED_MODULE_0__.Kb,obb=new OrientedBox,obb2=new OrientedBox;return function intersectsGeometry(nodeIndex32,geometry,otherGeometry,geometryToBvh,cachedObb=null){let nodeIndex16=2*nodeIndex32,float32Array=_float32Array,uint16Array=_uint16Array,uint32Array=_uint32Array;null===cachedObb&&(otherGeometry.boundingBox||otherGeometry.computeBoundingBox(),obb.set(otherGeometry.boundingBox.min,otherGeometry.boundingBox.max,geometryToBvh),cachedObb=obb);if(!IS_LEAF(nodeIndex16,uint16Array)){const left=nodeIndex32+8,right=uint32Array[nodeIndex32+6];arrayToBox(left,float32Array,boundingBox$1);if(cachedObb.intersectsBox(boundingBox$1)&&intersectsGeometry(left,geometry,otherGeometry,geometryToBvh,cachedObb))return!0;arrayToBox(right,float32Array,boundingBox$1);return!!(cachedObb.intersectsBox(boundingBox$1)&&intersectsGeometry(right,geometry,otherGeometry,geometryToBvh,cachedObb))}{const thisGeometry=geometry,thisIndex=thisGeometry.index,thisPos=thisGeometry.attributes.position,index=otherGeometry.index,pos=otherGeometry.attributes.position,offset=OFFSET(nodeIndex32,uint32Array),count=COUNT(nodeIndex16,uint16Array);if(invertedMat.copy(geometryToBvh).invert(),otherGeometry.boundsTree){arrayToBox(nodeIndex32,float32Array,obb2),obb2.matrix.copy(invertedMat),obb2.needsUpdate=!0;return otherGeometry.boundsTree.shapecast({intersectsBounds:box=>obb2.intersectsBox(box),intersectsTriangle:tri=>{tri.a.applyMatrix4(geometryToBvh),tri.b.applyMatrix4(geometryToBvh),tri.c.applyMatrix4(geometryToBvh),tri.needsUpdate=!0;for(let i=3*offset,l=3*(count+offset);i<l;i+=3)if(setTriangle(triangle2,i,thisIndex,thisPos),triangle2.needsUpdate=!0,tri.intersectsTriangle(triangle2))return!0;return!1}})}for(let i=3*offset,l=count+3*offset;i<l;i+=3){setTriangle(triangle,i,thisIndex,thisPos),triangle.a.applyMatrix4(invertedMat),triangle.b.applyMatrix4(invertedMat),triangle.c.applyMatrix4(invertedMat),triangle.needsUpdate=!0;for(let i2=0,l2=index.count;i2<l2;i2+=3)if(setTriangle(triangle2,i2,index,pos),triangle2.needsUpdate=!0,triangle.intersectsTriangle(triangle2))return!0}}}}();function intersectRay(nodeIndex32,array,ray,target){return arrayToBox(nodeIndex32,array,boundingBox$1),ray.intersectBox(boundingBox$1,target)}const bufferStack=[];let _prevBuffer,_float32Array,_uint16Array,_uint32Array;function setBuffer(buffer){_prevBuffer&&bufferStack.push(_prevBuffer),_prevBuffer=buffer,_float32Array=new Float32Array(buffer),_uint16Array=new Uint16Array(buffer),_uint32Array=new Uint32Array(buffer)}function clearBuffer(){_prevBuffer=null,_float32Array=null,_uint16Array=null,_uint32Array=null,bufferStack.length&&setBuffer(bufferStack.pop())}const SKIP_GENERATION=Symbol("skip tree generation"),aabb=new three__WEBPACK_IMPORTED_MODULE_0__.k,aabb2=new three__WEBPACK_IMPORTED_MODULE_0__.k,tempMatrix=new three__WEBPACK_IMPORTED_MODULE_0__.Kb,obb=new OrientedBox,obb2=new OrientedBox,temp=new three__WEBPACK_IMPORTED_MODULE_0__.ud,temp1=new three__WEBPACK_IMPORTED_MODULE_0__.ud,temp2=new three__WEBPACK_IMPORTED_MODULE_0__.ud,temp3=new three__WEBPACK_IMPORTED_MODULE_0__.ud,temp4=new three__WEBPACK_IMPORTED_MODULE_0__.ud,tempBox=new three__WEBPACK_IMPORTED_MODULE_0__.k,trianglePool=new PrimitivePool((()=>new SeparatingAxisTriangle));class MeshBVH{static serialize(bvh,options={}){if(options.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),MeshBVH.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});options={cloneBuffers:!0,...options};const geometry=bvh.geometry,rootData=bvh._roots,indexAttribute=geometry.getIndex();let result;return result=options.cloneBuffers?{roots:rootData.map((root=>root.slice())),index:indexAttribute.array.slice()}:{roots:rootData,index:indexAttribute.array},result}static deserialize(data,geometry,options={}){if("boolean"==typeof options)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),MeshBVH.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});options={setIndex:!0,...options};const{index:index,roots:roots}=data,bvh=new MeshBVH(geometry,{...options,[SKIP_GENERATION]:!0});if(bvh._roots=roots,options.setIndex){const indexAttribute=geometry.getIndex();if(null===indexAttribute){const newIndex=new three__WEBPACK_IMPORTED_MODULE_0__.o(data.index,1,!1);geometry.setIndex(newIndex)}else indexAttribute.array!==index&&(indexAttribute.array.set(index),indexAttribute.needsUpdate=!0)}return bvh}constructor(geometry,options={}){if(!geometry.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(geometry.index&&geometry.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((options=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[SKIP_GENERATION]:!1},options)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,options[SKIP_GENERATION]||(this._roots=function buildPackedTree(geo,options){const roots=buildTree(geo,options);let float32Array,uint32Array,uint16Array;const packedRoots=[],BufferConstructor=options.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let i=0;i<roots.length;i++){const root=roots[i],buffer=new BufferConstructor(32*countNodes(root));float32Array=new Float32Array(buffer),uint32Array=new Uint32Array(buffer),uint16Array=new Uint16Array(buffer),populateBuffer(0,root),packedRoots.push(buffer)}return packedRoots;function countNodes(node){return node.count?1:1+countNodes(node.left)+countNodes(node.right)}function populateBuffer(byteOffset,node){const stride4Offset=byteOffset/4,stride2Offset=byteOffset/2,isLeaf=!!node.count,boundingData=node.boundingData;for(let i=0;i<6;i++)float32Array[stride4Offset+i]=boundingData[i];if(isLeaf){const offset=node.offset,count=node.count;return uint32Array[stride4Offset+6]=offset,uint16Array[stride2Offset+14]=count,uint16Array[stride2Offset+15]=65535,byteOffset+32}{const left=node.left,right=node.right,splitAxis=node.splitAxis;let nextUnusedPointer;if(nextUnusedPointer=populateBuffer(byteOffset+32,left),nextUnusedPointer/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return uint32Array[stride4Offset+6]=nextUnusedPointer/4,nextUnusedPointer=populateBuffer(nextUnusedPointer,right),uint32Array[stride4Offset+7]=splitAxis,nextUnusedPointer}}}(geometry,options),!geometry.boundingBox&&options.setBoundingBox&&(geometry.boundingBox=this.getBoundingBox(new three__WEBPACK_IMPORTED_MODULE_0__.k))),this.geometry=geometry}refit(nodeIndices=null){nodeIndices&&Array.isArray(nodeIndices)&&(nodeIndices=new Set(nodeIndices));const geometry=this.geometry,indexArr=geometry.index.array,posAttr=geometry.attributes.position,posArr=posAttr.array,bufferOffset=posAttr.offset||0;let buffer,uint32Array,uint16Array,float32Array,stride=3;posAttr.isInterleavedBufferAttribute&&(stride=posAttr.data.stride);let byteOffset=0;const roots=this._roots;for(let i=0,l=roots.length;i<l;i++)buffer=roots[i],uint32Array=new Uint32Array(buffer),uint16Array=new Uint16Array(buffer),float32Array=new Float32Array(buffer),_traverse(0,byteOffset),byteOffset+=buffer.byteLength;function _traverse(node32Index,byteOffset,force=!1){const node16Index=2*node32Index;if(65535===uint16Array[node16Index+15]){const offset=uint32Array[node32Index+6];let minx=1/0,miny=1/0,minz=1/0,maxx=-1/0,maxy=-1/0,maxz=-1/0;for(let i=3*offset,l=3*(offset+uint16Array[node16Index+14]);i<l;i++){const index=indexArr[i]*stride+bufferOffset,x=posArr[index+0],y=posArr[index+1],z=posArr[index+2];x<minx&&(minx=x),x>maxx&&(maxx=x),y<miny&&(miny=y),y>maxy&&(maxy=y),z<minz&&(minz=z),z>maxz&&(maxz=z)}return(float32Array[node32Index+0]!==minx||float32Array[node32Index+1]!==miny||float32Array[node32Index+2]!==minz||float32Array[node32Index+3]!==maxx||float32Array[node32Index+4]!==maxy||float32Array[node32Index+5]!==maxz)&&(float32Array[node32Index+0]=minx,float32Array[node32Index+1]=miny,float32Array[node32Index+2]=minz,float32Array[node32Index+3]=maxx,float32Array[node32Index+4]=maxy,float32Array[node32Index+5]=maxz,!0)}{const left=node32Index+8,right=uint32Array[node32Index+6],offsetLeft=left+byteOffset,offsetRight=right+byteOffset;let forceChildren=force,includesLeft=!1,includesRight=!1;nodeIndices?forceChildren||(includesLeft=nodeIndices.has(offsetLeft),includesRight=nodeIndices.has(offsetRight),forceChildren=!includesLeft&&!includesRight):(includesLeft=!0,includesRight=!0);const traverseRight=forceChildren||includesRight;let leftChange=!1;(forceChildren||includesLeft)&&(leftChange=_traverse(left,byteOffset,forceChildren));let rightChange=!1;traverseRight&&(rightChange=_traverse(right,byteOffset,forceChildren));const didChange=leftChange||rightChange;if(didChange)for(let i=0;i<3;i++){const lefti=left+i,righti=right+i,minLeftValue=float32Array[lefti],maxLeftValue=float32Array[lefti+3],minRightValue=float32Array[righti],maxRightValue=float32Array[righti+3];float32Array[node32Index+i]=minLeftValue<minRightValue?minLeftValue:minRightValue,float32Array[node32Index+i+3]=maxLeftValue>maxRightValue?maxLeftValue:maxRightValue}return didChange}}}traverse(callback,rootIndex=0){const buffer=this._roots[rootIndex],uint32Array=new Uint32Array(buffer),uint16Array=new Uint16Array(buffer);!function _traverse(node32Index,depth=0){const node16Index=2*node32Index,isLeaf=65535===uint16Array[node16Index+15];if(isLeaf){const offset=uint32Array[node32Index+6],count=uint16Array[node16Index+14];callback(depth,isLeaf,new Float32Array(buffer,4*node32Index,6),offset,count)}else{const left=node32Index+8,right=uint32Array[node32Index+6],splitAxis=uint32Array[node32Index+7];callback(depth,isLeaf,new Float32Array(buffer,4*node32Index,6),splitAxis)||(_traverse(left,depth+1),_traverse(right,depth+1))}}(0)}raycast(ray,materialOrSide=three__WEBPACK_IMPORTED_MODULE_0__.Y){const roots=this._roots,geometry=this.geometry,intersects=[],isMaterial=materialOrSide.isMaterial,isArrayMaterial=Array.isArray(materialOrSide),groups=geometry.groups,side=isMaterial?materialOrSide.side:materialOrSide;for(let i=0,l=roots.length;i<l;i++){const materialSide=isArrayMaterial?materialOrSide[groups[i].materialIndex].side:side,startCount=intersects.length;if(setBuffer(roots[i]),raycast(0,geometry,materialSide,ray,intersects),clearBuffer(),isArrayMaterial){const materialIndex=groups[i].materialIndex;for(let j=startCount,jl=intersects.length;j<jl;j++)intersects[j].face.materialIndex=materialIndex}}return intersects}raycastFirst(ray,materialOrSide=three__WEBPACK_IMPORTED_MODULE_0__.Y){const roots=this._roots,geometry=this.geometry,isMaterial=materialOrSide.isMaterial,isArrayMaterial=Array.isArray(materialOrSide);let closestResult=null;const groups=geometry.groups,side=isMaterial?materialOrSide.side:materialOrSide;for(let i=0,l=roots.length;i<l;i++){const materialSide=isArrayMaterial?materialOrSide[groups[i].materialIndex].side:side;setBuffer(roots[i]);const result=raycastFirst(0,geometry,materialSide,ray);clearBuffer(),null!=result&&(null==closestResult||result.distance<closestResult.distance)&&(closestResult=result,isArrayMaterial&&(result.face.materialIndex=groups[i].materialIndex))}return closestResult}intersectsGeometry(otherGeometry,geomToMesh){const geometry=this.geometry;let result=!1;for(const root of this._roots)if(setBuffer(root),result=intersectsGeometry(0,geometry,otherGeometry,geomToMesh),clearBuffer(),result)break;return result}shapecast(callbacks,_intersectsTriangleFunc,_orderNodesFunc){const geometry=this.geometry;if(callbacks instanceof Function){if(_intersectsTriangleFunc){const originalTriangleFunc=_intersectsTriangleFunc;_intersectsTriangleFunc=(tri,index,contained,depth)=>{const i3=3*index;return originalTriangleFunc(tri,i3,i3+1,i3+2,contained,depth)}}callbacks={boundsTraverseOrder:_orderNodesFunc,intersectsBounds:callbacks,intersectsTriangle:_intersectsTriangleFunc,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const triangle=trianglePool.getPrimitive();let{boundsTraverseOrder:boundsTraverseOrder,intersectsBounds:intersectsBounds,intersectsRange:intersectsRange,intersectsTriangle:intersectsTriangle}=callbacks;if(intersectsRange&&intersectsTriangle){const originalIntersectsRange=intersectsRange;intersectsRange=(offset,count,contained,depth,nodeIndex)=>!!originalIntersectsRange(offset,count,contained,depth,nodeIndex)||iterateOverTriangles(offset,count,geometry,intersectsTriangle,contained,depth,triangle)}else intersectsRange||(intersectsRange=intersectsTriangle?(offset,count,contained,depth)=>iterateOverTriangles(offset,count,geometry,intersectsTriangle,contained,depth,triangle):(offset,count,contained)=>contained);let result=!1,byteOffset=0;for(const root of this._roots){if(setBuffer(root),result=shapecast(0,geometry,intersectsBounds,intersectsRange,boundsTraverseOrder,byteOffset),clearBuffer(),result)break;byteOffset+=root.byteLength}return trianglePool.releasePrimitive(triangle),result}bvhcast(otherBvh,matrixToLocal,callbacks){let{intersectsRanges:intersectsRanges,intersectsTriangles:intersectsTriangles}=callbacks;const indexAttr=this.geometry.index,positionAttr=this.geometry.attributes.position,otherIndexAttr=otherBvh.geometry.index,otherPositionAttr=otherBvh.geometry.attributes.position;tempMatrix.copy(matrixToLocal).invert();const triangle=trianglePool.getPrimitive(),triangle2=trianglePool.getPrimitive();if(intersectsTriangles){function iterateOverDoubleTriangles(offset1,count1,offset2,count2,depth1,index1,depth2,index2){for(let i2=offset2,l2=offset2+count2;i2<l2;i2++){setTriangle(triangle2,3*i2,otherIndexAttr,otherPositionAttr),triangle2.a.applyMatrix4(matrixToLocal),triangle2.b.applyMatrix4(matrixToLocal),triangle2.c.applyMatrix4(matrixToLocal),triangle2.needsUpdate=!0;for(let i1=offset1,l1=offset1+count1;i1<l1;i1++)if(setTriangle(triangle,3*i1,indexAttr,positionAttr),triangle.needsUpdate=!0,intersectsTriangles(triangle,triangle2,i1,i2,depth1,index1,depth2,index2))return!0}return!1}if(intersectsRanges){const originalIntersectsRanges=intersectsRanges;intersectsRanges=function(offset1,count1,offset2,count2,depth1,index1,depth2,index2){return!!originalIntersectsRanges(offset1,count1,offset2,count2,depth1,index1,depth2,index2)||iterateOverDoubleTriangles(offset1,count1,offset2,count2,depth1,index1,depth2,index2)}}else intersectsRanges=iterateOverDoubleTriangles}this.getBoundingBox(aabb2),aabb2.applyMatrix4(matrixToLocal);const result=this.shapecast({intersectsBounds:box=>aabb2.intersectsBox(box),intersectsRange:(offset1,count1,contained,depth1,nodeIndex1,box)=>(aabb.copy(box),aabb.applyMatrix4(tempMatrix),otherBvh.shapecast({intersectsBounds:box=>aabb.intersectsBox(box),intersectsRange:(offset2,count2,contained,depth2,nodeIndex2)=>intersectsRanges(offset1,count1,offset2,count2,depth1,nodeIndex1,depth2,nodeIndex2)}))});return trianglePool.releasePrimitive(triangle),trianglePool.releasePrimitive(triangle2),result}intersectsBox(box,boxToMesh){return obb.set(box.min,box.max,boxToMesh),obb.needsUpdate=!0,this.shapecast({intersectsBounds:box=>obb.intersectsBox(box),intersectsTriangle:tri=>obb.intersectsTriangle(tri)})}intersectsSphere(sphere){return this.shapecast({intersectsBounds:box=>sphere.intersectsBox(box),intersectsTriangle:tri=>tri.intersectsSphere(sphere)})}closestPointToGeometry(otherGeometry,geometryToBvh,target1={},target2={},minThreshold=0,maxThreshold=1/0){otherGeometry.boundingBox||otherGeometry.computeBoundingBox(),obb.set(otherGeometry.boundingBox.min,otherGeometry.boundingBox.max,geometryToBvh),obb.needsUpdate=!0;const geometry=this.geometry,pos=geometry.attributes.position,index=geometry.index,otherPos=otherGeometry.attributes.position,otherIndex=otherGeometry.index,triangle=trianglePool.getPrimitive(),triangle2=trianglePool.getPrimitive();let tempTarget1=temp1,tempTargetDest1=temp2,tempTarget2=null,tempTargetDest2=null;target2&&(tempTarget2=temp3,tempTargetDest2=temp4);let closestDistance=1/0,closestDistanceTriIndex=null,closestDistanceOtherTriIndex=null;return tempMatrix.copy(geometryToBvh).invert(),obb2.matrix.copy(tempMatrix),this.shapecast({boundsTraverseOrder:box=>obb.distanceToBox(box,Math.min(closestDistance,maxThreshold)),intersectsBounds:(box,isLeaf,score)=>score<closestDistance&&score<maxThreshold&&(isLeaf&&(obb2.min.copy(box.min),obb2.max.copy(box.max),obb2.needsUpdate=!0),!0),intersectsRange:(offset,count)=>{if(otherGeometry.boundsTree)return otherGeometry.boundsTree.shapecast({boundsTraverseOrder:box=>obb2.distanceToBox(box,Math.min(closestDistance,maxThreshold)),intersectsBounds:(box,isLeaf,score)=>score<closestDistance&&score<maxThreshold,intersectsRange:(otherOffset,otherCount)=>{for(let i2=3*otherOffset,l2=3*(otherOffset+otherCount);i2<l2;i2+=3){setTriangle(triangle2,i2,otherIndex,otherPos),triangle2.a.applyMatrix4(geometryToBvh),triangle2.b.applyMatrix4(geometryToBvh),triangle2.c.applyMatrix4(geometryToBvh),triangle2.needsUpdate=!0;for(let i=3*offset,l=3*(offset+count);i<l;i+=3){setTriangle(triangle,i,index,pos),triangle.needsUpdate=!0;const dist=triangle.distanceToTriangle(triangle2,tempTarget1,tempTarget2);if(dist<closestDistance&&(tempTargetDest1.copy(tempTarget1),tempTargetDest2&&tempTargetDest2.copy(tempTarget2),closestDistance=dist,closestDistanceTriIndex=i/3,closestDistanceOtherTriIndex=i2/3),dist<minThreshold)return!0}}}});for(let i2=0,l2=otherIndex?otherIndex.count:otherPos.count;i2<l2;i2+=3){setTriangle(triangle2,i2,otherIndex,otherPos),triangle2.a.applyMatrix4(geometryToBvh),triangle2.b.applyMatrix4(geometryToBvh),triangle2.c.applyMatrix4(geometryToBvh),triangle2.needsUpdate=!0;for(let i=3*offset,l=3*(offset+count);i<l;i+=3){setTriangle(triangle,i,index,pos),triangle.needsUpdate=!0;const dist=triangle.distanceToTriangle(triangle2,tempTarget1,tempTarget2);if(dist<closestDistance&&(tempTargetDest1.copy(tempTarget1),tempTargetDest2&&tempTargetDest2.copy(tempTarget2),closestDistance=dist,closestDistanceTriIndex=i/3,closestDistanceOtherTriIndex=i2/3),dist<minThreshold)return!0}}}}),trianglePool.releasePrimitive(triangle),trianglePool.releasePrimitive(triangle2),closestDistance===1/0?null:(target1.point?target1.point.copy(tempTargetDest1):target1.point=tempTargetDest1.clone(),target1.distance=closestDistance,target1.faceIndex=closestDistanceTriIndex,target2&&(target2.point?target2.point.copy(tempTargetDest2):target2.point=tempTargetDest2.clone(),target2.point.applyMatrix4(tempMatrix),tempTargetDest1.applyMatrix4(tempMatrix),target2.distance=tempTargetDest1.sub(target2.point).length(),target2.faceIndex=closestDistanceOtherTriIndex),target1)}closestPointToPoint(point,target={},minThreshold=0,maxThreshold=1/0){const minThresholdSq=minThreshold*minThreshold,maxThresholdSq=maxThreshold*maxThreshold;let closestDistanceSq=1/0,closestDistanceTriIndex=null;if(this.shapecast({boundsTraverseOrder:box=>(temp.copy(point).clamp(box.min,box.max),temp.distanceToSquared(point)),intersectsBounds:(box,isLeaf,score)=>score<closestDistanceSq&&score<maxThresholdSq,intersectsTriangle:(tri,triIndex)=>{tri.closestPointToPoint(point,temp);const distSq=point.distanceToSquared(temp);return distSq<closestDistanceSq&&(temp1.copy(temp),closestDistanceSq=distSq,closestDistanceTriIndex=triIndex),distSq<minThresholdSq}}),closestDistanceSq===1/0)return null;const closestDistance=Math.sqrt(closestDistanceSq);return target.point?target.point.copy(temp1):target.point=temp1.clone(),target.distance=closestDistance,target.faceIndex=closestDistanceTriIndex,target}getBoundingBox(target){target.makeEmpty();return this._roots.forEach((buffer=>{arrayToBox(0,new Float32Array(buffer),tempBox),target.union(tempBox)})),target}}const originalRaycast=MeshBVH.prototype.raycast;MeshBVH.prototype.raycast=function(...args){if(args[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[mesh,raycaster,ray,intersects]=args;return originalRaycast.call(this,ray,mesh.material).forEach((hit=>{(hit=convertRaycastIntersect(hit,mesh,raycaster))&&intersects.push(hit)})),intersects}return originalRaycast.apply(this,args)};const originalRaycastFirst=MeshBVH.prototype.raycastFirst;MeshBVH.prototype.raycastFirst=function(...args){if(args[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[mesh,raycaster,ray]=args;return convertRaycastIntersect(originalRaycastFirst.call(this,ray,mesh.material),mesh,raycaster)}return originalRaycastFirst.apply(this,args)};const originalClosestPointToPoint=MeshBVH.prototype.closestPointToPoint;MeshBVH.prototype.closestPointToPoint=function(...args){if(args[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),args.unshift();const target=args[1],result={};return args[1]=result,originalClosestPointToPoint.apply(this,args),target&&target.copy(result.point),result.distance}return originalClosestPointToPoint.apply(this,args)};const originalClosestPointToGeometry=MeshBVH.prototype.closestPointToGeometry;MeshBVH.prototype.closestPointToGeometry=function(...args){const target1=args[2],target2=args[3];if(target1&&target1.isVector3||target2&&target2.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const result1={},result2={},geometryToBvh=args[1];return args[2]=result1,args[3]=result2,originalClosestPointToGeometry.apply(this,args),target1&&target1.copy(result1.point),target2&&target2.copy(result2.point).applyMatrix4(geometryToBvh),result1.distance}return originalClosestPointToGeometry.apply(this,args)};const originalRefit=MeshBVH.prototype.refit;MeshBVH.prototype.refit=function(...args){const nodeIndices=args[0],terminationIndices=args[1];if(terminationIndices&&(terminationIndices instanceof Set||Array.isArray(terminationIndices))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const newNodeIndices=new Set;terminationIndices.forEach((v=>newNodeIndices.add(v))),nodeIndices&&nodeIndices.forEach((v=>newNodeIndices.add(v))),originalRefit.call(this,newNodeIndices)}else originalRefit.apply(this,args)},["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach((name=>{const originalFunc=MeshBVH.prototype[name];MeshBVH.prototype[name]=function(...args){return(null===args[0]||args[0].isMesh)&&(args.shift(),console.warn(`MeshBVH: The function signature for "${name}" has changed and no longer takes Mesh. See docs for new signature.`)),originalFunc.apply(this,args)}}));const boundingBox=new three__WEBPACK_IMPORTED_MODULE_0__.k;class MeshBVHRootVisualizer extends three__WEBPACK_IMPORTED_MODULE_0__.ec{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(mesh,material,depth=10,group=0){super(),this.material=material,this.geometry=new three__WEBPACK_IMPORTED_MODULE_0__.p,this.name="MeshBVHRootVisualizer",this.depth=depth,this.displayParents=!1,this.mesh=mesh,this.displayEdges=!0,this._group=group}raycast(){}update(){const geometry=this.geometry,boundsTree=this.mesh.geometry.boundsTree,group=this._group;if(geometry.dispose(),this.visible=!1,boundsTree){const targetDepth=this.depth-1,displayParents=this.displayParents;let boundsCount=0;boundsTree.traverse(((depth,isLeaf)=>{if(depth===targetDepth||isLeaf)return boundsCount++,!0;displayParents&&boundsCount++}),group);let posIndex=0;const positionArray=new Float32Array(24*boundsCount);let indexArray,indices;boundsTree.traverse(((depth,isLeaf,boundingData)=>{const terminate=depth===targetDepth||isLeaf;if(terminate||displayParents){arrayToBox(0,boundingData,boundingBox);const{min:min,max:max}=boundingBox;for(let x=-1;x<=1;x+=2){const xVal=x<0?min.x:max.x;for(let y=-1;y<=1;y+=2){const yVal=y<0?min.y:max.y;for(let z=-1;z<=1;z+=2){const zVal=z<0?min.z:max.z;positionArray[posIndex+0]=xVal,positionArray[posIndex+1]=yVal,positionArray[posIndex+2]=zVal,posIndex+=3}}}return terminate}}),group),indices=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),indexArray=positionArray.length>65535?new Uint32Array(indices.length*boundsCount):new Uint16Array(indices.length*boundsCount);const indexLength=indices.length;for(let i=0;i<boundsCount;i++){const posOffset=8*i,indexOffset=i*indexLength;for(let j=0;j<indexLength;j++)indexArray[indexOffset+j]=posOffset+indices[j]}geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.o(indexArray,1,!1)),geometry.setAttribute("position",new three__WEBPACK_IMPORTED_MODULE_0__.o(positionArray,3,!1)),this.visible=!0}}}class MeshBVHVisualizer extends three__WEBPACK_IMPORTED_MODULE_0__.db{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(v){this.edgeMaterial.opacity=v,this.meshMaterial.opacity=v}constructor(mesh,depth=10){super(),this.name="MeshBVHVisualizer",this.depth=depth,this.mesh=mesh,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const edgeMaterial=new three__WEBPACK_IMPORTED_MODULE_0__.sb({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),meshMaterial=new three__WEBPACK_IMPORTED_MODULE_0__.Mb({color:65416,transparent:!0,opacity:.3,depthWrite:!1});meshMaterial.color=edgeMaterial.color,this.edgeMaterial=edgeMaterial,this.meshMaterial=meshMaterial,this.update()}update(){const bvh=this.mesh.geometry.boundsTree,totalRoots=bvh?bvh._roots.length:0;for(;this._roots.length>totalRoots;)this._roots.pop();for(let i=0;i<totalRoots;i++){if(i>=this._roots.length){const root=new MeshBVHRootVisualizer(this.mesh,this.edgeMaterial,this.depth,i);this.add(root),this._roots.push(root)}const root=this._roots[i];root.depth=this.depth,root.mesh=this.mesh,root.displayParents=this.displayParents,root.displayEdges=this.displayEdges,root.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,root.update()}}updateMatrixWorld(...args){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...args)}copy(source){this.depth=source.depth,this.mesh=source.mesh}clone(){return new MeshBVHVisualizer(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const children=this.children;for(let i=0,l=children.length;i<l;i++)children[i].geometry.dispose()}}three__WEBPACK_IMPORTED_MODULE_0__.Lb.prototype.raycast;three__WEBPACK_IMPORTED_MODULE_0__.D},"./node_modules/lingo3d/lib/display/core/SimpleObjectManager/PhysicsItem/bvh/computeBVH.js":function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return bvhManagerMap}));var _Primitive__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/lingo3d/lib/display/core/Primitive.js"),_bvh__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/lingo3d/lib/display/core/SimpleObjectManager/PhysicsItem/bvh/bvh.js");const bvhManagerMap=new WeakMap;__webpack_exports__.b=item=>{item.outerObject3d.updateMatrixWorld(!0);const geometries=[];item.outerObject3d.traverse((c=>{if(!c.geometry||c===item.object3d&&!(item instanceof _Primitive__WEBPACK_IMPORTED_MODULE_0__.a))return;const geom=c.geometry.clone();geom.applyMatrix4(c.matrixWorld),geometries.push(geom),geom.dispose()}));const bvhComputed=[];for(const geom of geometries){const bvh=geom.boundsTree=new _bvh__WEBPACK_IMPORTED_MODULE_1__.a(geom);bvhComputed.push(bvh),bvhManagerMap.set(bvh,item)}return[bvhComputed,geometries]}},"./node_modules/lingo3d/lib/states/useBVHMap.js":function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"c",(function(){return pushBVHMap})),__webpack_require__.d(__webpack_exports__,"b",(function(){return pullBVHMap})),__webpack_require__.d(__webpack_exports__,"a",(function(){return getBVHMap}));var _lincode_reactivity__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@lincode/reactivity/lib/index.js");const[setBVHMap,getBVHMap]=Object(_lincode_reactivity__WEBPACK_IMPORTED_MODULE_0__.e)([]),pushBVHMap=Object(_lincode_reactivity__WEBPACK_IMPORTED_MODULE_0__.g)(setBVHMap,getBVHMap),pullBVHMap=Object(_lincode_reactivity__WEBPACK_IMPORTED_MODULE_0__.f)(setBVHMap,getBVHMap)}}]);